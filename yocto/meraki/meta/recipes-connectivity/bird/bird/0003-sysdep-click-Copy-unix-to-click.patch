diff --git a/sysdep/click/Doc b/sysdep/click/Doc
new file mode 100644
index 00000000..a17f425b
--- /dev/null
+++ b/sysdep/click/Doc
@@ -0,0 +1,3 @@
+S log.c
+S krt.c
+# io.c is documented under Resources
diff --git a/sysdep/click/Modules b/sysdep/click/Modules
new file mode 100644
index 00000000..8aeed504
--- /dev/null
+++ b/sysdep/click/Modules
@@ -0,0 +1,17 @@
+log.c
+main.c
+timer.h
+io.c
+unix.h
+endian.h
+config.Y
+random.c
+
+krt.c
+krt.h
+krt.Y
+kif.c
+kif.h
+kif.Y
+sysio.h
+syspriv.h
diff --git a/sysdep/click/config.Y b/sysdep/click/config.Y
new file mode 100644
index 00000000..15a87f53
--- /dev/null
+++ b/sysdep/click/config.Y
@@ -0,0 +1,152 @@
+/*
+ *	BIRD -- UNIX Configuration
+ *
+ *	(c) 1999--2000 Martin Mares <mj@ucw.cz>
+ *
+ *	Can be freely distributed and used under the terms of the GNU GPL.
+ */
+
+CF_HDR
+
+#include "lib/unix.h"
+#include <stdio.h>
+
+CF_DECLS
+
+CF_KEYWORDS(LOG, SYSLOG, ALL, DEBUG, TRACE, INFO, REMOTE, WARNING, ERROR, AUTH, FATAL, BUG, STDERR, SOFT)
+CF_KEYWORDS(TIMEFORMAT, ISO, OLD, SHORT, LONG, BASE, NAME, CONFIRM, UNDO, CHECK, TIMEOUT)
+
+%type <i> log_mask log_mask_list log_cat cfg_timeout
+%type <g> log_file
+%type <t> cfg_name
+%type <tf> timeformat_which
+%type <t> syslog_name
+
+CF_GRAMMAR
+
+CF_ADDTO(conf, log_config)
+
+log_config: LOG log_file log_mask ';' {
+    struct log_config *c = cfg_allocz(sizeof(struct log_config));
+    c->fh = $2;
+    c->mask = $3;
+    add_tail(&new_config->logfiles, &c->n);
+  }
+ ;
+
+syslog_name:
+   NAME TEXT { $$ = $2; }
+ | { $$ = bird_name; }
+ ;
+
+log_file:
+   TEXT {
+     struct rfile *f = rf_open(new_config->pool, $1, "a");
+     if (!f) cf_error("Unable to open log file `%s': %m", $1);
+     $$ = rf_file(f);
+   }
+ | SYSLOG syslog_name { $$ = NULL; new_config->syslog_name = $2; }
+ | STDERR { $$ = stderr; }
+ ;
+
+log_mask:
+   ALL { $$ = ~0; }
+ | '{' log_mask_list '}' { $$ = $2; }
+ ;
+
+log_mask_list:
+   log_cat { $$ = 1 << $1; }
+ | log_mask_list ',' log_cat { $$ = $1 | (1 << $3); }
+ ;
+
+log_cat:
+   DEBUG { $$ = L_DEBUG[0]; }
+ | TRACE { $$ = L_TRACE[0]; }
+ | INFO { $$ = L_INFO[0]; }
+ | REMOTE { $$ = L_REMOTE[0]; }
+ | WARNING { $$ = L_WARN[0]; }
+ | ERROR { $$ = L_ERR[0]; }
+ | AUTH { $$ = L_AUTH[0]; }
+ | FATAL { $$ = L_FATAL[0]; }
+ | BUG { $$ = L_BUG[0]; }
+ ;
+
+
+CF_ADDTO(conf, mrtdump_base)
+
+mrtdump_base:
+   MRTDUMP PROTOCOLS mrtdump_mask ';' { new_config->proto_default_mrtdump = $3; }
+ | MRTDUMP TEXT ';' {
+     struct rfile *f = rf_open(new_config->pool, $2, "a");
+     if (!f) cf_error("Unable to open MRTDump file '%s': %m", $2);
+     new_config->mrtdump_file = rf_fileno(f);
+   }
+ ;
+
+CF_ADDTO(conf, timeformat_base)
+
+timeformat_which:
+   ROUTE { $$ = &new_config->tf_route; }
+ | PROTOCOL { $$ = &new_config->tf_proto; }
+ | BASE { $$ = &new_config->tf_base; }
+ | LOG { $$ = &new_config->tf_log; }
+
+timeformat_spec:
+   timeformat_which TEXT { *$1 = (struct timeformat){$2, NULL, 0}; }
+ | timeformat_which TEXT expr TEXT { *$1 = (struct timeformat){$2, $4, $3}; }
+ | timeformat_which ISO SHORT { *$1 = (struct timeformat){"%T", "%F", 20*3600}; }
+ | timeformat_which ISO LONG  { *$1 = (struct timeformat){"%F %T", NULL, 0}; }
+ | timeformat_which OLD SHORT { *$1 = (struct timeformat){NULL, NULL, 0}; }
+ | timeformat_which OLD LONG  { *$1 = (struct timeformat){"%d-%m-%Y %T", NULL, 0}; }
+ ;
+
+timeformat_base:
+   TIMEFORMAT timeformat_spec ';'
+ ;
+
+/* Unix specific commands */
+
+CF_CLI_HELP(CONFIGURE, ..., [[Reload configuration]])
+
+CF_CLI(CONFIGURE, cfg_name cfg_timeout, [\"<file>\"] [timeout [<sec>]], [[Reload configuration]])
+{ cmd_reconfig($2, RECONFIG_HARD, $3); } ;
+
+CF_CLI(CONFIGURE SOFT, cfg_name cfg_timeout, [\"<file>\"] [timeout [<sec>]], [[Reload configuration and ignore changes in filters]])
+{ cmd_reconfig($3, RECONFIG_SOFT, $4); } ;
+
+/* Hack to get input completion for 'timeout' */
+CF_CLI_CMD(CONFIGURE TIMEOUT, [<sec>], [[Reload configuration with undo timeout]])
+CF_CLI_CMD(CONFIGURE SOFT TIMEOUT, [<sec>], [[Reload configuration with undo timeout]])
+
+CF_CLI(CONFIGURE CONFIRM,,, [[Confirm last configuration change - deactivate undo timeout]])
+{ cmd_reconfig_confirm(); } ;
+
+CF_CLI(CONFIGURE UNDO,,, [[Undo last configuration change]])
+{ cmd_reconfig_undo(); } ;
+
+CF_CLI(CONFIGURE CHECK, cfg_name, [\"<file>\"], [[Parse configuration and check its validity]])
+{ cmd_check_config($3); } ;
+
+CF_CLI(DOWN,,, [[Shut the daemon down]])
+{ cmd_shutdown(); } ;
+
+CF_CLI(SHOW SOCKPROXY STATS,,, [[Show libsockproxy stats]])
+{ cmd_sockproxy_stats(); } ;
+
+CF_CLI(RESET SOCKPROXY STATS,,, [[Reset libsockproxy stats]])
+{ cmd_sockproxy_reset_stats(); } ;
+
+cfg_name:
+   /* empty */ { $$ = NULL; }
+ | TEXT
+ ;
+
+cfg_timeout:
+   /* empty */ { $$ = 0; }
+ | TIMEOUT { $$ = UNIX_DEFAULT_CONFIGURE_TIMEOUT; }
+ | TIMEOUT expr { $$ = $2; }
+ ;
+
+CF_CODE
+
+CF_END
diff --git a/sysdep/click/endian.h b/sysdep/click/endian.h
new file mode 100644
index 00000000..bc486313
--- /dev/null
+++ b/sysdep/click/endian.h
@@ -0,0 +1,20 @@
+/*
+ *	BIRD -- Endianity Conversion
+ *
+ *	(c) 1999 Martin Mares <mj@ucw.cz>
+ *
+ *	Can be freely distributed and used under the terms of the GNU GPL.
+ */
+
+#ifndef _BIRD_ENDIAN_H_
+#define _BIRD_ENDIAN_H_
+
+/* hton[sl] and ntoh[sl] are defined here */
+
+#include <sys/types.h>
+#include <netinet/in.h>
+#ifdef HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
+#endif
diff --git a/sysdep/click/io.c b/sysdep/click/io.c
new file mode 100644
index 00000000..cd68728d
--- /dev/null
+++ b/sysdep/click/io.c
@@ -0,0 +1,2315 @@
+/*
+ *  BIRD Internet Routing Daemon -- Meraki Unix I/O
+ *
+ *  (c) 1998--2004 Martin Mares <mj@ucw.cz>
+ *      (c) 2004       Ondrej Filip <feela@network.cz>
+ *      (c) 2014--2017 Cisco Systems, Inc.
+ *
+ *	Can be freely distributed and used under the terms of the GNU GPL.
+ */
+
+/* Unfortunately, some glibc versions hide parts of RFC 3542 API
+   if _GNU_SOURCE is not defined. */
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <netinet/udp.h>
+#include <netinet/icmp6.h>
+
+#include "nest/bird.h"
+#include "lib/lists.h"
+#include "lib/resource.h"
+#include "lib/timer.h"
+#include "lib/socket.h"
+#include "lib/event.h"
+#include "lib/string.h"
+#include "nest/iface.h"
+
+#include "lib/unix.h"
+#include "lib/sysio.h"
+
+int sk_priority_control = 7;
+
+/* Maximum number of calls of tx handler for one socket in one
+ * poll iteration. Should be small enough to not monopolize CPU by
+ * one protocol instance.
+ */
+#define MAX_STEPS 4
+
+/* Maximum number of calls of rx handler for all sockets in one poll
+   iteration. RX callbacks are often much more costly so we limit
+   this to gen small latencies */
+#define MAX_RX_STEPS 4
+
+
+/*
+ *	Tracked Files
+ */
+
+struct rfile {
+  resource r;
+  FILE *f;
+};
+
+static void
+rf_free(resource *r)
+{
+  struct rfile *a = (struct rfile *) r;
+
+  fclose(a->f);
+}
+
+static void
+rf_dump(resource *r)
+{
+  struct rfile *a = (struct rfile *) r;
+
+  debug("(FILE *%p)\n", a->f);
+}
+
+static struct resclass rf_class = {
+  "FILE",
+  sizeof(struct rfile),
+  rf_free,
+  rf_dump,
+  NULL,
+  NULL
+};
+
+struct rfile *
+rf_open(pool *p, char *name, char *mode)
+{
+  FILE *f = fopen(name, mode);
+
+  if (!f)
+    return NULL;
+
+  struct rfile *r = ralloc(p, &rf_class);
+  r->f = f;
+  return r;
+}
+
+void *
+rf_file(struct rfile *f)
+{
+  return f->f;
+}
+
+int
+rf_fileno(struct rfile *f)
+{
+  return fileno(f->f);
+}
+
+/**
+ * DOC: Timers
+ *
+ * Timers are resources which represent a wish of a module to call
+ * a function at the specified time. The platform dependent code
+ * doesn't guarantee exact timing, only that a timer function
+ * won't be called before the requested time.
+ *
+ * In BIRD, time is represented by values of the &bird_clock_t type
+ * which are integral numbers interpreted as a relative number of seconds since
+ * some fixed time point in past. The current time can be read
+ * from variable @now with reasonable accuracy and is monotonic. There is also
+ * a current 'absolute' time in variable @now_real reported by OS.
+ *
+ * Each timer is described by a &timer structure containing a pointer
+ * to the handler function (@hook), data private to this function (@data),
+ * time the function should be called at (@expires, 0 for inactive timers),
+ * for the other fields see |timer.h|.
+ */
+
+#define NEAR_TIMER_LIMIT 4
+
+static list near_timers, far_timers;
+static bird_clock_t first_far_timer = TIME_INFINITY;
+
+/* now must be different from 0, because 0 is a special value in timer->expires */
+bird_clock_t now = 1, now_real, boot_time;
+
+static void
+update_times_plain(void)
+{
+  bird_clock_t new_time = time(NULL);
+  int delta = new_time - now_real;
+
+  if ((delta >= 0) && (delta < 60))
+    now += delta;
+  else if (now_real != 0)
+   log(L_WARN "Time jump, delta %d s", delta);
+
+  now_real = new_time;
+}
+
+static void
+update_times_gettime(void)
+{
+  struct timespec ts;
+  int rv;
+
+  rv = clock_gettime(CLOCK_MONOTONIC, &ts);
+  if (rv != 0)
+    die("clock_gettime: %m");
+
+  if (ts.tv_sec != now) {
+    if (ts.tv_sec < now)
+      log(L_ERR "Monotonic timer is broken");
+
+    now = ts.tv_sec;
+    now_real = time(NULL);
+  }
+}
+
+static int clock_monotonic_available;
+
+static inline void
+update_times(void)
+{
+  if (clock_monotonic_available)
+    update_times_gettime();
+  else
+    update_times_plain();
+}
+
+static inline void
+init_times(void)
+{
+ struct timespec ts;
+ clock_monotonic_available = (clock_gettime(CLOCK_MONOTONIC, &ts) == 0);
+ if (!clock_monotonic_available)
+   log(L_WARN "Monotonic timer is missing");
+}
+
+
+static void
+tm_free(resource *r)
+{
+  timer *t = (timer *) r;
+
+  tm_stop(t);
+}
+
+static void
+tm_dump(resource *r)
+{
+  timer *t = (timer *) r;
+
+  debug("(code %p, data %p, ", t->hook, t->data);
+  if (t->randomize)
+    debug("rand %d, ", t->randomize);
+  if (t->recurrent)
+    debug("recur %d, ", t->recurrent);
+  if (t->expires)
+    debug("expires in %d sec)\n", t->expires - now);
+  else
+    debug("inactive)\n");
+}
+
+static struct resclass tm_class = {
+  "Timer",
+  sizeof(timer),
+  tm_free,
+  tm_dump,
+  NULL,
+  NULL
+};
+
+/**
+ * tm_new - create a timer
+ * @p: pool
+ *
+ * This function creates a new timer resource and returns
+ * a pointer to it. To use the timer, you need to fill in
+ * the structure fields and call tm_start() to start timing.
+ */
+timer *
+tm_new(pool *p)
+{
+  timer *t = ralloc(p, &tm_class);
+  return t;
+}
+
+static inline void
+tm_insert_near(timer *t)
+{
+  node *n = HEAD(near_timers);
+
+  while (n->next && (SKIP_BACK(timer, n, n)->expires < t->expires))
+    n = n->next;
+  insert_node(&t->n, n->prev);
+}
+
+/**
+ * tm_start - start a timer
+ * @t: timer
+ * @after: number of seconds the timer should be run after
+ *
+ * This function schedules the hook function of the timer to
+ * be called after @after seconds. If the timer has been already
+ * started, it's @expire time is replaced by the new value.
+ *
+ * You can have set the @randomize field of @t, the timeout
+ * will be increased by a random number of seconds chosen
+ * uniformly from range 0 .. @randomize.
+ *
+ * You can call tm_start() from the handler function of the timer
+ * to request another run of the timer. Also, you can set the @recurrent
+ * field to have the timer re-added automatically with the same timeout.
+ */
+void
+tm_start(timer *t, unsigned after)
+{
+  bird_clock_t when;
+
+  if (t->randomize)
+    after += random() % (t->randomize + 1);
+  when = now + after;
+  if (t->expires == when)
+    return;
+  if (t->expires)
+    rem_node(&t->n);
+  t->expires = when;
+  if (after <= NEAR_TIMER_LIMIT)
+    tm_insert_near(t);
+  else
+    {
+      if (!first_far_timer || first_far_timer > when)
+	first_far_timer = when;
+      add_tail(&far_timers, &t->n);
+    }
+}
+
+/**
+ * tm_stop - stop a timer
+ * @t: timer
+ *
+ * This function stops a timer. If the timer is already stopped,
+ * nothing happens.
+ */
+void
+tm_stop(timer *t)
+{
+  if (t->expires)
+    {
+      rem_node(&t->n);
+      t->expires = 0;
+    }
+}
+
+static void
+tm_dump_them(char *name, list *l)
+{
+  node *n;
+  timer *t;
+
+  debug("%s timers:\n", name);
+  WALK_LIST(n, *l)
+    {
+      t = SKIP_BACK(timer, n, n);
+      debug("%p ", t);
+      tm_dump(&t->r);
+    }
+  debug("\n");
+}
+
+void
+tm_dump_all(void)
+{
+  tm_dump_them("Near", &near_timers);
+  tm_dump_them("Far", &far_timers);
+}
+
+static inline time_t
+tm_first_shot(void)
+{
+  time_t x = first_far_timer;
+
+  if (!EMPTY_LIST(near_timers))
+    {
+      timer *t = SKIP_BACK(timer, n, HEAD(near_timers));
+      if (t->expires < x)
+	x = t->expires;
+    }
+  return x;
+}
+
+void io_log_event(void *hook, void *data);
+
+static void
+tm_shot(void)
+{
+  timer *t;
+  node *n, *m;
+
+  if (first_far_timer <= now)
+    {
+      bird_clock_t limit = now + NEAR_TIMER_LIMIT;
+      first_far_timer = TIME_INFINITY;
+      n = HEAD(far_timers);
+      while (m = n->next)
+	{
+	  t = SKIP_BACK(timer, n, n);
+	  if (t->expires <= limit)
+	    {
+	      rem_node(n);
+	      tm_insert_near(t);
+	    }
+	  else if (t->expires < first_far_timer)
+	    first_far_timer = t->expires;
+	  n = m;
+	}
+    }
+  while ((n = HEAD(near_timers)) -> next)
+    {
+      int delay;
+      t = SKIP_BACK(timer, n, n);
+      if (t->expires > now)
+	break;
+      rem_node(n);
+      delay = t->expires - now;
+      t->expires = 0;
+      if (t->recurrent)
+	{
+	  int i = t->recurrent - delay;
+	  if (i < 0)
+	    i = 0;
+	  tm_start(t, i);
+	}
+      io_log_event(t->hook, t->data);
+      t->hook(t);
+    }
+}
+
+/**
+ * tm_parse_datetime - parse a date and time
+ * @x: datetime string
+ *
+ * tm_parse_datetime() takes a textual representation of
+ * a date and time (dd-mm-yyyy hh:mm:ss)
+ * and converts it to the corresponding value of type &bird_clock_t.
+ */
+bird_clock_t
+tm_parse_datetime(char *x)
+{
+  struct tm tm;
+  int n;
+  time_t t;
+
+  if (sscanf(x, "%d-%d-%d %d:%d:%d%n", &tm.tm_mday, &tm.tm_mon, &tm.tm_year, &tm.tm_hour, &tm.tm_min, &tm.tm_sec, &n) != 6 || x[n])
+    return tm_parse_date(x);
+  tm.tm_mon--;
+  tm.tm_year -= 1900;
+  t = mktime(&tm);
+  if (t == (time_t) -1)
+    return 0;
+  return t;
+}
+/**
+ * tm_parse_date - parse a date
+ * @x: date string
+ *
+ * tm_parse_date() takes a textual representation of a date (dd-mm-yyyy)
+ * and converts it to the corresponding value of type &bird_clock_t.
+ */
+bird_clock_t
+tm_parse_date(char *x)
+{
+  struct tm tm;
+  int n;
+  time_t t;
+
+  if (sscanf(x, "%d-%d-%d%n", &tm.tm_mday, &tm.tm_mon, &tm.tm_year, &n) != 3 || x[n])
+    return 0;
+  tm.tm_mon--;
+  tm.tm_year -= 1900;
+  tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
+  t = mktime(&tm);
+  if (t == (time_t) -1)
+    return 0;
+  return t;
+}
+
+static void
+tm_format_reltime(char *x, struct tm *tm, bird_clock_t delta)
+{
+  static char *month_names[12] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
+				   "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
+
+  if (delta < 20*3600)
+    bsprintf(x, "%02d:%02d", tm->tm_hour, tm->tm_min);
+  else if (delta < 360*86400)
+    bsprintf(x, "%s%02d", month_names[tm->tm_mon], tm->tm_mday);
+  else
+    bsprintf(x, "%d", tm->tm_year+1900);
+}
+
+#include "conf/conf.h"
+
+/**
+ * tm_format_datetime - convert date and time to textual representation
+ * @x: destination buffer of size %TM_DATETIME_BUFFER_SIZE
+ * @fmt_spec: specification of resulting textual representation of the time
+ * @t: time
+ *
+ * This function formats the given relative time value @t to a textual
+ * date/time representation (dd-mm-yyyy hh:mm:ss) in real time.
+ */
+void
+tm_format_datetime(char *x, struct timeformat *fmt_spec, bird_clock_t t)
+{
+  const char *fmt_used;
+  struct tm *tm;
+  bird_clock_t delta = now - t;
+  t = now_real - delta;
+  tm = localtime(&t);
+
+  if (fmt_spec->fmt1 == NULL)
+    return tm_format_reltime(x, tm, delta);
+
+  if ((fmt_spec->limit == 0) || (delta < fmt_spec->limit))
+    fmt_used = fmt_spec->fmt1;
+  else
+    fmt_used = fmt_spec->fmt2;
+
+  int rv = strftime(x, TM_DATETIME_BUFFER_SIZE, fmt_used, tm);
+  if (((rv == 0) && fmt_used[0]) || (rv == TM_DATETIME_BUFFER_SIZE))
+    strcpy(x, "<too-long>");
+}
+
+int
+tm_format_real_time(char *x, size_t max, const char *fmt, bird_clock_t t)
+{
+  struct tm tm;
+
+  if (!localtime_r(&t, &tm))
+    return 0;
+
+  if (!strftime(x, max, fmt, &tm))
+    return 0;
+
+  return 1;
+}
+
+
+/**
+ * DOC: Sockets
+ *
+ * Socket resources represent network connections. Their data structure (&socket)
+ * contains a lot of fields defining the exact type of the socket, the local and
+ * remote addresses and ports, pointers to socket buffers and finally pointers to
+ * hook functions to be called when new data have arrived to the receive buffer
+ * (@rx_hook), when the contents of the transmit buffer have been transmitted
+ * (@tx_hook) and when an error or connection close occurs (@err_hook).
+ *
+ * Freeing of sockets from inside socket hooks is perfectly safe.
+ */
+
+#ifndef SOL_IP
+#define SOL_IP IPPROTO_IP
+#endif
+
+#ifndef SOL_IPV6
+#define SOL_IPV6 IPPROTO_IPV6
+#endif
+
+#ifndef SOL_ICMPV6
+#define SOL_ICMPV6 IPPROTO_ICMPV6
+#endif
+
+
+/*
+ *	Sockaddr helper functions
+ */
+
+static inline int UNUSED sockaddr_length(int af)
+{ return (af == AF_INET) ? sizeof(struct sockaddr_in) : sizeof(struct sockaddr_in6); }
+
+static inline void
+sockaddr_fill4(struct sockaddr_in *sa, ip_addr a, uint port)
+{
+  memset(sa, 0, sizeof(struct sockaddr_in));
+#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN
+  sa->sin_len = sizeof(struct sockaddr_in);
+#endif
+  sa->sin_family = AF_INET;
+  sa->sin_port = htons(port);
+  sa->sin_addr = ipa_to_in4(a);
+}
+
+static inline void
+sockaddr_fill6(struct sockaddr_in6 *sa, ip_addr a, struct iface *ifa, uint port)
+{
+  memset(sa, 0, sizeof(struct sockaddr_in6));
+#ifdef SIN6_LEN
+  sa->sin6_len = sizeof(struct sockaddr_in6);
+#endif
+  sa->sin6_family = AF_INET6;
+  sa->sin6_port = htons(port);
+  sa->sin6_flowinfo = 0;
+  sa->sin6_addr = ipa_to_in6(a);
+
+  if (ifa && ipa_is_link_local(a))
+    sa->sin6_scope_id = ifa->index;
+}
+
+void
+sockaddr_fill(sockaddr *sa, int af, ip_addr a, struct iface *ifa, uint port)
+{
+  if (af == AF_INET)
+    sockaddr_fill4((struct sockaddr_in *) sa, a, port);
+  else if (af == AF_INET6)
+    sockaddr_fill6((struct sockaddr_in6 *) sa, a, ifa, port);
+  else
+    bug("Unknown AF");
+}
+
+static inline void
+sockaddr_read4(struct sockaddr_in *sa, ip_addr *a, uint *port)
+{
+  *port = ntohs(sa->sin_port);
+  *a = ipa_from_in4(sa->sin_addr);
+}
+
+static inline void
+sockaddr_read6(struct sockaddr_in6 *sa, ip_addr *a, struct iface **ifa, uint *port)
+{
+  *port = ntohs(sa->sin6_port);
+  *a = ipa_from_in6(sa->sin6_addr);
+
+  if (ifa && ipa_is_link_local(*a))
+    *ifa = if_find_by_index(sa->sin6_scope_id);
+}
+
+int
+sockaddr_read(sockaddr *sa, int af, ip_addr *a, struct iface **ifa, uint *port)
+{
+  if (sa->sa.sa_family != af)
+    goto fail;
+
+  if (af == AF_INET)
+    sockaddr_read4((struct sockaddr_in *) sa, a, port);
+  else if (af == AF_INET6)
+    sockaddr_read6((struct sockaddr_in6 *) sa, a, ifa, port);
+  else
+    goto fail;
+
+  return 0;
+
+ fail:
+  *a = IPA_NONE;
+  *port = 0;
+  return -1;
+}
+
+
+/*
+ *	IPv6 multicast syscalls
+ */
+
+/* Fortunately standardized in RFC 3493 */
+
+#define INIT_MREQ6(maddr,ifa) \
+  { .ipv6mr_multiaddr = ipa_to_in6(maddr), .ipv6mr_interface = ifa->index }
+
+static inline int
+sk_setup_multicast6(sock *s)
+{
+  int index = s->iface->index;
+  int ttl = s->ttl;
+  int n = 0;
+
+  if (CSP_setsockopt(s->fd, SOL_IPV6, IPV6_MULTICAST_IF, &index, sizeof(index)) < 0)
+    ERR("IPV6_MULTICAST_IF");
+
+  if (CSP_setsockopt(s->fd, SOL_IPV6, IPV6_MULTICAST_HOPS, &ttl, sizeof(ttl)) < 0)
+    ERR("IPV6_MULTICAST_HOPS");
+
+  if (CSP_setsockopt(s->fd, SOL_IPV6, IPV6_MULTICAST_LOOP, &n, sizeof(n)) < 0)
+    ERR("IPV6_MULTICAST_LOOP");
+
+  return 0;
+}
+
+static inline int
+sk_join_group6(sock *s, ip_addr maddr)
+{
+  struct ipv6_mreq mr = INIT_MREQ6(maddr, s->iface);
+
+  if (CSP_setsockopt(s->fd, SOL_IPV6, IPV6_JOIN_GROUP, &mr, sizeof(mr)) < 0)
+    ERR("IPV6_JOIN_GROUP");
+
+  return 0;
+}
+
+static inline int
+sk_leave_group6(sock *s, ip_addr maddr)
+{
+  struct ipv6_mreq mr = INIT_MREQ6(maddr, s->iface);
+
+  if (CSP_setsockopt(s->fd, SOL_IPV6, IPV6_LEAVE_GROUP, &mr, sizeof(mr)) < 0)
+    ERR("IPV6_LEAVE_GROUP");
+
+  return 0;
+}
+
+
+/*
+ *	IPv6 packet control messages
+ */
+
+/* Also standardized, in RFC 3542 */
+
+/*
+ * RFC 2292 uses IPV6_PKTINFO for both the socket option and the cmsg
+ * type, RFC 3542 changed the socket option to IPV6_RECVPKTINFO. If we
+ * don't have IPV6_RECVPKTINFO we suppose the OS implements the older
+ * RFC and we use IPV6_PKTINFO.
+ */
+#ifndef IPV6_RECVPKTINFO
+#define IPV6_RECVPKTINFO IPV6_PKTINFO
+#endif
+/*
+ * Same goes for IPV6_HOPLIMIT -> IPV6_RECVHOPLIMIT.
+ */
+#ifndef IPV6_RECVHOPLIMIT
+#define IPV6_RECVHOPLIMIT IPV6_HOPLIMIT
+#endif
+
+
+#define CMSG6_SPACE_PKTINFO CMSG_SPACE(sizeof(struct in6_pktinfo))
+#define CMSG6_SPACE_TTL CMSG_SPACE(sizeof(int))
+
+static inline int
+sk_request_cmsg6_pktinfo(sock *s)
+{
+  int y = 1;
+
+  if (CSP_setsockopt(s->fd, SOL_IPV6, IPV6_RECVPKTINFO, &y, sizeof(y)) < 0)
+    ERR("IPV6_RECVPKTINFO");
+
+  return 0;
+}
+
+static inline int
+sk_request_cmsg6_ttl(sock *s)
+{
+  int y = 1;
+
+  if (CSP_setsockopt(s->fd, SOL_IPV6, IPV6_RECVHOPLIMIT, &y, sizeof(y)) < 0)
+    ERR("IPV6_RECVHOPLIMIT");
+
+  return 0;
+}
+
+static inline void
+sk_process_cmsg6_pktinfo(sock *s, struct cmsghdr *cm)
+{
+  if (cm->cmsg_type == IPV6_PKTINFO)
+  {
+    struct in6_pktinfo *pi = (struct in6_pktinfo *) CMSG_DATA(cm);
+    s->laddr = ipa_from_in6(pi->ipi6_addr);
+    s->lifindex = pi->ipi6_ifindex;
+  }
+}
+
+static inline void
+sk_process_cmsg6_ttl(sock *s, struct cmsghdr *cm)
+{
+  if (cm->cmsg_type == IPV6_HOPLIMIT)
+    s->rcv_ttl = * (int *) CMSG_DATA(cm);
+}
+
+static inline void
+sk_prepare_cmsgs6(sock *s, struct msghdr *msg, void *cbuf, size_t cbuflen)
+{
+  struct cmsghdr *cm;
+  struct in6_pktinfo *pi;
+  int controllen = 0;
+
+  msg->msg_control = cbuf;
+  msg->msg_controllen = cbuflen;
+
+  cm = CMSG_FIRSTHDR(msg);
+  cm->cmsg_level = SOL_IPV6;
+  cm->cmsg_type = IPV6_PKTINFO;
+  cm->cmsg_len = CMSG_LEN(sizeof(*pi));
+  controllen += CMSG_SPACE(sizeof(*pi));
+
+  pi = (struct in6_pktinfo *) CMSG_DATA(cm);
+  pi->ipi6_ifindex = s->iface ? s->iface->index : 0;
+  pi->ipi6_addr = ipa_to_in6(s->saddr);
+
+  msg->msg_controllen = controllen;
+}
+
+
+/*
+ *	Miscellaneous socket syscalls
+ */
+
+static inline int
+sk_set_ttl4(sock *s, int ttl)
+{
+  if (CSP_setsockopt(s->fd, SOL_IP, IP_TTL, &ttl, sizeof(ttl)) < 0)
+    ERR("IP_TTL");
+
+  return 0;
+}
+
+static inline int
+sk_set_ttl6(sock *s, int ttl)
+{
+  if (CSP_setsockopt(s->fd, SOL_IPV6, IPV6_UNICAST_HOPS, &ttl, sizeof(ttl)) < 0)
+    ERR("IPV6_UNICAST_HOPS");
+
+  return 0;
+}
+
+static inline int
+sk_set_tos4(sock *s, int tos)
+{
+  if (CSP_setsockopt(s->fd, SOL_IP, IP_TOS, &tos, sizeof(tos)) < 0)
+    ERR("IP_TOS");
+
+  return 0;
+}
+
+static inline int
+sk_set_tos6(sock *s, int tos)
+{
+  if (CSP_setsockopt(s->fd, SOL_IPV6, IPV6_TCLASS, &tos, sizeof(tos)) < 0)
+    ERR("IPV6_TCLASS");
+
+  return 0;
+}
+
+static inline int
+sk_set_high_port(sock *s UNUSED)
+{
+  /* Port range setting is optional, ignore it if not supported */
+
+#ifdef IP_PORTRANGE
+  if (sk_is_ipv4(s))
+  {
+    int range = IP_PORTRANGE_HIGH;
+    if (CSP_setsockopt(s->fd, SOL_IP, IP_PORTRANGE, &range, sizeof(range)) < 0)
+      ERR("IP_PORTRANGE");
+  }
+#endif
+
+#ifdef IPV6_PORTRANGE
+  if (sk_is_ipv6(s))
+  {
+    int range = IPV6_PORTRANGE_HIGH;
+    if (CSP_setsockopt(s->fd, SOL_IPV6, IPV6_PORTRANGE, &range, sizeof(range)) < 0)
+      ERR("IPV6_PORTRANGE");
+  }
+#endif
+
+  return 0;
+}
+
+static inline byte *
+sk_skip_ip_header(byte *pkt, int *len)
+{
+  if ((*len < 20) || ((*pkt & 0xf0) != 0x40))
+    return NULL;
+
+  int hlen = (*pkt & 0x0f) * 4;
+  if ((hlen < 20) || (hlen > *len))
+    return NULL;
+
+  *len -= hlen;
+  return pkt + hlen;
+}
+
+byte *
+sk_rx_buffer(sock *s, int *len)
+{
+  if (sk_is_ipv4(s) && (s->type == SK_IP))
+    return sk_skip_ip_header(s->rbuf, len);
+  else
+    return s->rbuf;
+}
+
+
+/*
+ *	Public socket functions
+ */
+
+/**
+ * sk_setup_multicast - enable multicast for given socket
+ * @s: socket
+ *
+ * Prepare transmission of multicast packets for given datagram socket.
+ * The socket must have defined @iface.
+ *
+ * Result: 0 for success, -1 for an error.
+ */
+
+int
+sk_setup_multicast(sock *s)
+{
+  ASSERT(s->iface);
+
+  if (sk_is_ipv4(s))
+    return sk_setup_multicast4(s);
+  else
+    return sk_setup_multicast6(s);
+}
+
+/**
+ * sk_join_group - join multicast group for given socket
+ * @s: socket
+ * @maddr: multicast address
+ *
+ * Join multicast group for given datagram socket and associated interface.
+ * The socket must have defined @iface.
+ *
+ * Result: 0 for success, -1 for an error.
+ */
+
+int
+sk_join_group(sock *s, ip_addr maddr)
+{
+  if (sk_is_ipv4(s))
+    return sk_join_group4(s, maddr);
+  else
+    return sk_join_group6(s, maddr);
+}
+
+/**
+ * sk_leave_group - leave multicast group for given socket
+ * @s: socket
+ * @maddr: multicast address
+ *
+ * Leave multicast group for given datagram socket and associated interface.
+ * The socket must have defined @iface.
+ *
+ * Result: 0 for success, -1 for an error.
+ */
+
+int
+sk_leave_group(sock *s, ip_addr maddr)
+{
+  if (sk_is_ipv4(s))
+    return sk_leave_group4(s, maddr);
+  else
+    return sk_leave_group6(s, maddr);
+}
+
+/**
+ * sk_setup_broadcast - enable broadcast for given socket
+ * @s: socket
+ *
+ * Allow reception and transmission of broadcast packets for given datagram
+ * socket. The socket must have defined @iface. For transmission, packets should
+ * be send to @brd address of @iface.
+ *
+ * Result: 0 for success, -1 for an error.
+ */
+
+int
+sk_setup_broadcast(sock *s)
+{
+  int y = 1;
+
+  if (CSP_setsockopt(s->fd, SOL_SOCKET, SO_BROADCAST, &y, sizeof(y)) < 0)
+    ERR("SO_BROADCAST");
+
+  return 0;
+}
+
+/**
+ * sk_set_ttl - set transmit TTL for given socket
+ * @s: socket
+ * @ttl: TTL value
+ *
+ * Set TTL for already opened connections when TTL was not set before. Useful
+ * for accepted connections when different ones should have different TTL.
+ *
+ * Result: 0 for success, -1 for an error.
+ */
+
+int
+sk_set_ttl(sock *s, int ttl)
+{
+  s->ttl = ttl;
+
+  if (sk_is_ipv4(s))
+    return sk_set_ttl4(s, ttl);
+  else
+    return sk_set_ttl6(s, ttl);
+}
+
+/**
+ * sk_set_min_ttl - set minimal accepted TTL for given socket
+ * @s: socket
+ * @ttl: TTL value
+ *
+ * Set minimal accepted TTL for given socket. Can be used for TTL security.
+ * implementations.
+ *
+ * Result: 0 for success, -1 for an error.
+ */
+
+int
+sk_set_min_ttl(sock *s, int ttl)
+{
+  if (sk_is_ipv4(s))
+    return sk_set_min_ttl4(s, ttl);
+  else
+    return sk_set_min_ttl6(s, ttl);
+}
+
+/**
+ * sk_set_md5_auth - add / remove MD5 security association for given socket
+ * @s: socket
+ * @local: IP address of local side
+ * @remote: IP address of remote side
+ * @ifa: Interface for link-local IP address
+ * @passwd: Password used for MD5 authentication
+ * @setkey: Update also system SA/SP database
+ *
+ * In TCP MD5 handling code in kernel, there is a set of security associations
+ * used for choosing password and other authentication parameters according to
+ * the local and remote address. This function is useful for listening socket,
+ * for active sockets it may be enough to set s->password field.
+ *
+ * When called with passwd != NULL, the new pair is added,
+ * When called with passwd == NULL, the existing pair is removed.
+ *
+ * Note that while in Linux, the MD5 SAs are specific to socket, in BSD they are
+ * stored in global SA/SP database (but the behavior also must be enabled on
+ * per-socket basis). In case of multiple sockets to the same neighbor, the
+ * socket-specific state must be configured for each socket while global state
+ * just once per src-dst pair. The @setkey argument controls whether the global
+ * state (SA/SP database) is also updated.
+ *
+ * Result: 0 for success, -1 for an error.
+ */
+int
+sk_set_md5_auth(sock *s, ip_addr local UNUSED, ip_addr remote, struct iface *ifa, char *passwd, int setkey UNUSED)
+{
+  struct tcp_md5sig md5;
+
+  memset(&md5, 0, sizeof(md5));
+  sockaddr_fill((sockaddr *) &md5.tcpm_addr, s->af, remote, ifa, 0);
+
+  if (passwd)
+  {
+    int len = strlen(passwd);
+
+    if (len > TCP_MD5SIG_MAXKEYLEN)
+      ERR_MSG("The password for TCP MD5 Signature is too long");
+
+    md5.tcpm_keylen = len;
+    memcpy(&md5.tcpm_key, passwd, len);
+  }
+
+  if (CSP_setsockopt(s->fd, SOL_TCP, TCP_MD5SIG, &md5, sizeof(md5)) < 0)
+  {
+    if (errno == ENOPROTOOPT)
+      ERR_MSG("Kernel does not support TCP MD5 signatures");
+    else
+      ERR("TCP_MD5SIG");
+  }
+
+  return 0;
+}
+
+/**
+ * sk_set_ipv6_checksum - specify IPv6 checksum offset for given socket
+ * @s: socket
+ * @offset: offset
+ *
+ * Specify IPv6 checksum field offset for given raw IPv6 socket. After that, the
+ * kernel will automatically fill it for outgoing packets and check it for
+ * incoming packets. Should not be used on ICMPv6 sockets, where the position is
+ * known to the kernel.
+ *
+ * Result: 0 for success, -1 for an error.
+ */
+
+int
+sk_set_ipv6_checksum(sock *s, int offset)
+{
+  if (CSP_setsockopt(s->fd, SOL_IPV6, IPV6_CHECKSUM, &offset, sizeof(offset)) < 0)
+    ERR("IPV6_CHECKSUM");
+
+  return 0;
+}
+
+int
+sk_set_icmp6_filter(sock *s, int p1, int p2)
+{
+  /* a bit of lame interface, but it is here only for Radv */
+  struct icmp6_filter f;
+
+  ICMP6_FILTER_SETBLOCKALL(&f);
+  ICMP6_FILTER_SETPASS(p1, &f);
+  ICMP6_FILTER_SETPASS(p2, &f);
+
+  if (CSP_setsockopt(s->fd, SOL_ICMPV6, ICMP6_FILTER, &f, sizeof(f)) < 0)
+    ERR("ICMP6_FILTER");
+
+  return 0;
+}
+
+void
+sk_log_error(sock *s, const char *p)
+{
+  log(L_ERR "%s: Socket error: %s%#m", p, s->err);
+}
+
+
+/*
+ *	Actual struct birdsock code
+ */
+
+static list sock_list;
+static struct birdsock *current_sock;
+static struct birdsock *stored_sock;
+static int sock_recalc_fdsets_p;
+
+static inline sock *
+sk_next(sock *s)
+{
+  if (!s->n.next->next)
+    return NULL;
+  else
+    return SKIP_BACK(sock, n, s->n.next);
+}
+
+static void
+sk_alloc_bufs(sock *s)
+{
+  if (!s->rbuf && s->rbsize)
+    s->rbuf = s->rbuf_alloc = xmalloc(s->rbsize);
+  s->rpos = s->rbuf;
+  if (!s->tbuf && s->tbsize)
+    s->tbuf = s->tbuf_alloc = xmalloc(s->tbsize);
+  s->tpos = s->ttx = s->tbuf;
+}
+
+static void
+sk_free_bufs(sock *s)
+{
+  if (s->rbuf_alloc)
+  {
+    xfree(s->rbuf_alloc);
+    s->rbuf = s->rbuf_alloc = NULL;
+  }
+  if (s->tbuf_alloc)
+  {
+    xfree(s->tbuf_alloc);
+    s->tbuf = s->tbuf_alloc = NULL;
+  }
+}
+
+static void
+sk_free(resource *r)
+{
+  sock *s = (sock *) r;
+
+  sk_free_bufs(s);
+  if (s->fd >= 0)
+  {
+    CSP_close(s->fd);
+
+    /* FIXME: we should call sk_stop() for SKF_THREAD sockets */
+    if (s->flags & SKF_THREAD)
+      return;
+
+    if (s == current_sock)
+      current_sock = sk_next(s);
+    if (s == stored_sock)
+      stored_sock = sk_next(s);
+    rem_node(&s->n);
+    sock_recalc_fdsets_p = 1;
+  }
+}
+
+void
+sk_set_rbsize(sock *s, uint val)
+{
+  ASSERT(s->rbuf_alloc == s->rbuf);
+
+  if (s->rbsize == val)
+    return;
+
+  s->rbsize = val;
+  xfree(s->rbuf_alloc);
+  s->rbuf_alloc = xmalloc(val);
+  s->rpos = s->rbuf = s->rbuf_alloc;
+}
+
+void
+sk_set_tbsize(sock *s, uint val)
+{
+  ASSERT(s->tbuf_alloc == s->tbuf);
+
+  if (s->tbsize == val)
+    return;
+
+  byte *old_tbuf = s->tbuf;
+
+  s->tbsize = val;
+  s->tbuf = s->tbuf_alloc = xrealloc(s->tbuf_alloc, val);
+  s->tpos = s->tbuf + (s->tpos - old_tbuf);
+  s->ttx  = s->tbuf + (s->ttx  - old_tbuf);
+}
+
+void
+sk_set_tbuf(sock *s, void *tbuf)
+{
+  s->tbuf = tbuf ?: s->tbuf_alloc;
+  s->ttx = s->tpos = s->tbuf;
+}
+
+void
+sk_reallocate(sock *s)
+{
+  sk_free_bufs(s);
+  sk_alloc_bufs(s);
+}
+
+static void
+sk_dump(resource *r)
+{
+  sock *s = (sock *) r;
+  static char *sk_type_names[] = { "TCP<", "TCP>", "TCP", "UDP", NULL, "IP", NULL, "MAGIC", "UNIX<", "UNIX", "DEL!" };
+
+  debug("(%s, ud=%p, sa=%I, sp=%d, da=%I, dp=%d, tos=%d, ttl=%d, if=%s)\n",
+	sk_type_names[s->type],
+	s->data,
+	s->saddr,
+	s->sport,
+	s->daddr,
+	s->dport,
+	s->tos,
+	s->ttl,
+	s->iface ? s->iface->name : "none");
+}
+
+static struct resclass sk_class = {
+  "Socket",
+  sizeof(sock),
+  sk_free,
+  sk_dump,
+  NULL,
+  NULL
+};
+
+/**
+ * sk_new - create a socket
+ * @p: pool
+ *
+ * This function creates a new socket resource. If you want to use it,
+ * you need to fill in all the required fields of the structure and
+ * call sk_open() to do the actual opening of the socket.
+ *
+ * The real function name is sock_new(), sk_new() is a macro wrapper
+ * to avoid collision with OpenSSL.
+ */
+sock *
+sock_new(pool *p)
+{
+  sock *s = ralloc(p, &sk_class);
+  s->pool = p;
+  // s->saddr = s->daddr = IPA_NONE;
+  s->tos = s->priority = s->ttl = -1;
+  s->fd = -1;
+  return s;
+}
+
+static int
+sk_setup(sock *s)
+{
+  int y = 1;
+  int fd = s->fd;
+
+  if (CSP_fcntl_int(fd, F_SETFL, O_NONBLOCK) < 0)
+    ERR("O_NONBLOCK");
+
+  if (!s->af)
+    return 0;
+
+  if (ipa_nonzero(s->saddr) && !(s->flags & SKF_BIND))
+    s->flags |= SKF_PKTINFO;
+
+#ifdef CONFIG_USE_HDRINCL
+  if (sk_is_ipv4(s) && (s->type == SK_IP) && (s->flags & SKF_PKTINFO))
+  {
+    s->flags &= ~SKF_PKTINFO;
+    s->flags |= SKF_HDRINCL;
+    if (CSP_setsockopt(fd, SOL_IP, IP_HDRINCL, &y, sizeof(y)) < 0)
+      ERR("IP_HDRINCL");
+  }
+#endif
+
+  if (s->vrf && !s->iface)
+  {
+    /* Bind socket to associated VRF interface.
+       This is Linux-specific, but so is SO_BINDTODEVICE. */
+#ifdef SO_BINDTODEVICE
+    struct ifreq ifr = {};
+    strcpy(ifr.ifr_name, s->vrf->name);
+    if (CSP_setsockopt(s->fd, SOL_SOCKET, SO_BINDTODEVICE, &ifr, sizeof(ifr)) < 0)
+      ERR("SO_BINDTODEVICE");
+#endif
+  }
+
+  if (s->iface)
+  {
+#ifdef SO_BINDTODEVICE
+    struct ifreq ifr = {};
+    strcpy(ifr.ifr_name, s->iface->name);
+    if (CSP_setsockopt(s->fd, SOL_SOCKET, SO_BINDTODEVICE, &ifr, sizeof(ifr)) < 0)
+      ERR("SO_BINDTODEVICE");
+#endif
+
+#ifdef CONFIG_UNIX_DONTROUTE
+    if (CSP_setsockopt(s->fd, SOL_SOCKET, SO_DONTROUTE, &y, sizeof(y)) < 0)
+      ERR("SO_DONTROUTE");
+#endif
+  }
+
+  if (sk_is_ipv4(s))
+  {
+    if (s->flags & SKF_LADDR_RX)
+      if (sk_request_cmsg4_pktinfo(s) < 0)
+	return -1;
+
+    if (s->flags & SKF_TTL_RX)
+      if (sk_request_cmsg4_ttl(s) < 0)
+	return -1;
+
+    if ((s->type == SK_UDP) || (s->type == SK_IP))
+      if (sk_disable_mtu_disc4(s) < 0)
+	return -1;
+
+    if (s->ttl >= 0)
+      if (sk_set_ttl4(s, s->ttl) < 0)
+	return -1;
+
+    if (s->tos >= 0)
+      if (sk_set_tos4(s, s->tos) < 0)
+	return -1;
+  }
+
+  if (sk_is_ipv6(s))
+  {
+    if (s->flags & SKF_V6ONLY)
+      if (CSP_setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, &y, sizeof(y)) < 0)
+	ERR("IPV6_V6ONLY");
+
+    if (s->flags & SKF_LADDR_RX)
+      if (sk_request_cmsg6_pktinfo(s) < 0)
+	return -1;
+
+    if (s->flags & SKF_TTL_RX)
+      if (sk_request_cmsg6_ttl(s) < 0)
+	return -1;
+
+    if ((s->type == SK_UDP) || (s->type == SK_IP))
+      if (sk_disable_mtu_disc6(s) < 0)
+	return -1;
+
+    if (s->ttl >= 0)
+      if (sk_set_ttl6(s, s->ttl) < 0)
+	return -1;
+
+    if (s->tos >= 0)
+      if (sk_set_tos6(s, s->tos) < 0)
+	return -1;
+  }
+
+  /* Must be after sk_set_tos4() as setting ToS on Linux also mangles priority */
+  if (s->priority >= 0)
+    if (sk_set_priority(s, s->priority) < 0)
+      return -1;
+
+  return 0;
+}
+
+static void
+sk_insert(sock *s)
+{
+  add_tail(&sock_list, &s->n);
+  sock_recalc_fdsets_p = 1;
+}
+
+static void
+sk_tcp_connected(sock *s)
+{
+  sockaddr sa;
+  int sa_len = sizeof(sa);
+
+  if ((CSP_getsockname(s->fd, &sa.sa, &sa_len) < 0) ||
+      (sockaddr_read(&sa, s->af, &s->saddr, &s->iface, &s->sport) < 0))
+    log(L_WARN "SOCK: Cannot get local IP address for TCP>");
+
+  s->type = SK_TCP;
+  sk_alloc_bufs(s);
+  s->tx_hook(s);
+}
+
+static int
+sk_passive_connected(sock *s, int type)
+{
+  sockaddr loc_sa, rem_sa;
+  int loc_sa_len = sizeof(loc_sa);
+  int rem_sa_len = sizeof(rem_sa);
+
+  int fd = accept(s->fd, ((type == SK_TCP) ? &rem_sa.sa : NULL), &rem_sa_len);
+  if (fd < 0)
+  {
+    if ((errno != EINTR) && (errno != EAGAIN))
+      s->err_hook(s, errno);
+    return 0;
+  }
+
+  sock *t = sk_new(s->pool);
+  t->type = type;
+  t->fd = fd;
+  t->af = s->af;
+  t->ttl = s->ttl;
+  t->tos = s->tos;
+  t->rbsize = s->rbsize;
+  t->tbsize = s->tbsize;
+
+  if (type == SK_TCP)
+  {
+    if ((CSP_getsockname(fd, &loc_sa.sa, &loc_sa_len) < 0) ||
+	(sockaddr_read(&loc_sa, s->af, &t->saddr, &t->iface, &t->sport) < 0))
+      log(L_WARN "SOCK: Cannot get local IP address for TCP<");
+
+    if (sockaddr_read(&rem_sa, s->af, &t->daddr, &t->iface, &t->dport) < 0)
+      log(L_WARN "SOCK: Cannot get remote IP address for TCP<");
+  }
+
+  if (sk_setup(t) < 0)
+  {
+    /* FIXME: Call err_hook instead ? */
+    log(L_ERR "SOCK: Incoming connection: %s%#m", t->err);
+
+    /* FIXME: handle it better in rfree() */
+    CSP_close(t->fd);
+    t->fd = -1;
+    rfree(t);
+    return 1;
+  }
+
+  sk_insert(t);
+  sk_alloc_bufs(t);
+  s->rx_hook(t, 0);
+  return 1;
+}
+
+/**
+ * sk_open - open a socket
+ * @s: socket
+ *
+ * This function takes a socket resource created by sk_new() and
+ * initialized by the user and binds a corresponding network connection
+ * to it.
+ *
+ * Result: 0 for success, -1 for an error.
+ */
+int
+sk_open(sock *s)
+{
+  int af = BIRD_AF;
+  int fd = -1;
+  int do_bind = 0;
+  int bind_port = 0;
+  ip_addr bind_addr = IPA_NONE;
+  sockaddr sa;
+
+  switch (s->type)
+  {
+  case SK_TCP_ACTIVE:
+    s->ttx = "";			/* Force s->ttx != s->tpos */
+    /* Fall thru */
+  case SK_TCP_PASSIVE:
+    fd = CSP_socket(af, SOCK_STREAM, IPPROTO_TCP);
+    bind_port = s->sport;
+    bind_addr = s->saddr;
+    do_bind = bind_port || ipa_nonzero(bind_addr);
+    break;
+
+  case SK_UDP:
+    fd = CSP_socket(af, SOCK_DGRAM, IPPROTO_UDP);
+    bind_port = s->sport;
+    bind_addr = (s->flags & SKF_BIND) ? s->saddr : IPA_NONE;
+    do_bind = 1;
+    break;
+
+  case SK_IP:
+    fd = CSP_socket(af, SOCK_RAW, s->dport);
+    bind_port = 0;
+    bind_addr = (s->flags & SKF_BIND) ? s->saddr : IPA_NONE;
+    do_bind = ipa_nonzero(bind_addr);
+    break;
+
+  case SK_MAGIC:
+    af = 0;
+    fd = s->fd;
+    break;
+
+  default:
+    bug("sk_open() called for invalid sock type %d", s->type);
+  }
+
+  if (fd < 0)
+    ERR("socket");
+
+  s->af = af;
+  s->fd = fd;
+
+  if (sk_setup(s) < 0)
+    goto err;
+
+  if (do_bind)
+  {
+    if (bind_port)
+    {
+      int y = 1;
+
+      if (CSP_setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &y, sizeof(y)) < 0)
+	ERR2("SO_REUSEADDR");
+
+#ifdef CONFIG_NO_IFACE_BIND
+      /* Workaround missing ability to bind to an iface */
+      if ((s->type == SK_UDP) && s->iface && ipa_zero(bind_addr))
+      {
+	if (CSP_setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &y, sizeof(y)) < 0)
+	  ERR2("SO_REUSEPORT");
+      }
+#endif
+    }
+    else
+      if (s->flags & SKF_HIGH_PORT)
+	if (sk_set_high_port(s) < 0)
+	  log(L_WARN "Socket error: %s%#m", s->err);
+
+    sockaddr_fill(&sa, af, bind_addr, s->iface, bind_port);
+    if (CSP_bind(fd, &sa.sa, SA_LEN(sa)) < 0)
+      ERR2("bind");
+  }
+
+  if (s->password)
+    if (sk_set_md5_auth(s, s->saddr, s->daddr, s->iface, s->password, 0) < 0)
+      goto err;
+
+  switch (s->type)
+  {
+  case SK_TCP_ACTIVE:
+    sockaddr_fill(&sa, af, s->daddr, s->iface, s->dport);
+    if (connect(fd, &sa.sa, SA_LEN(sa)) >= 0)
+      sk_tcp_connected(s);
+    else if (errno != EINTR && errno != EAGAIN && errno != EINPROGRESS &&
+	     errno != ECONNREFUSED && errno != EHOSTUNREACH && errno != ENETUNREACH)
+      ERR2("connect");
+    break;
+
+  case SK_TCP_PASSIVE:
+    if (listen(fd, 8) < 0)
+      ERR2("listen");
+    break;
+
+  case SK_MAGIC:
+    break;
+
+  default:
+    sk_alloc_bufs(s);
+  }
+
+  if (!(s->flags & SKF_THREAD))
+    sk_insert(s);
+  return 0;
+
+err:
+  CSP_close(fd);
+  s->fd = -1;
+  return -1;
+}
+
+int
+sk_open_unix(sock *s, char *name)
+{
+  struct sockaddr_un sa;
+  int fd;
+
+  /* We are sloppy during error (leak fd and not set s->err), but we die anyway */
+
+  fd = socket(AF_UNIX, SOCK_STREAM, 0);
+  if (fd < 0)
+    return -1;
+
+  if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0)
+    return -1;
+
+  /* Path length checked in test_old_bird() */
+  sa.sun_family = AF_UNIX;
+  strcpy(sa.sun_path, name);
+
+  if (bind(fd, (struct sockaddr *) &sa, SUN_LEN(&sa)) < 0)
+    return -1;
+
+  if (listen(fd, 8) < 0)
+    return -1;
+
+  s->fd = fd;
+  sk_insert(s);
+  return 0;
+}
+
+
+#define CMSG_RX_SPACE MAX(CMSG4_SPACE_PKTINFO+CMSG4_SPACE_TTL, \
+			  CMSG6_SPACE_PKTINFO+CMSG6_SPACE_TTL)
+#define CMSG_TX_SPACE MAX(CMSG4_SPACE_PKTINFO,CMSG6_SPACE_PKTINFO)
+
+static void
+sk_prepare_cmsgs(sock *s, struct msghdr *msg, void *cbuf, size_t cbuflen)
+{
+  if (sk_is_ipv4(s))
+    sk_prepare_cmsgs4(s, msg, cbuf, cbuflen);
+  else
+    sk_prepare_cmsgs6(s, msg, cbuf, cbuflen);
+}
+
+static void
+sk_process_cmsgs(sock *s, struct msghdr *msg)
+{
+  struct cmsghdr *cm;
+
+  s->laddr = IPA_NONE;
+  s->lifindex = 0;
+  s->rcv_ttl = -1;
+
+  for (cm = CMSG_FIRSTHDR(msg); cm != NULL; cm = CMSG_NXTHDR(msg, cm))
+  {
+    if ((cm->cmsg_level == SOL_IP) && sk_is_ipv4(s))
+    {
+      sk_process_cmsg4_pktinfo(s, cm);
+      sk_process_cmsg4_ttl(s, cm);
+    }
+
+    if ((cm->cmsg_level == SOL_IPV6) && sk_is_ipv6(s))
+    {
+      sk_process_cmsg6_pktinfo(s, cm);
+      sk_process_cmsg6_ttl(s, cm);
+    }
+  }
+}
+
+
+static inline int
+sk_sendmsg(sock *s)
+{
+  struct iovec iov = {s->tbuf, s->tpos - s->tbuf};
+  byte cmsg_buf[CMSG_TX_SPACE];
+  sockaddr dst;
+  int flags = 0;
+
+  sockaddr_fill(&dst, s->af, s->daddr, s->iface, s->dport);
+
+  struct msghdr msg = {
+    .msg_name = &dst.sa,
+    .msg_namelen = SA_LEN(dst),
+    .msg_iov = &iov,
+    .msg_iovlen = 1
+  };
+
+#ifdef CONFIG_DONTROUTE_UNICAST
+  /* FreeBSD silently changes TTL to 1 when MSG_DONTROUTE is used, therefore we
+     cannot use it for other cases (e.g. when TTL security is used). */
+  if (ipa_is_ip4(s->daddr) && ip4_is_unicast(ipa_to_ip4(s->daddr)) && (s->ttl == 1))
+    flags = MSG_DONTROUTE;
+#endif
+
+#ifdef CONFIG_USE_HDRINCL
+  byte hdr[20];
+  struct iovec iov2[2] = { {hdr, 20}, iov };
+
+  if (s->flags & SKF_HDRINCL)
+  {
+    sk_prepare_ip_header(s, hdr, iov.iov_len);
+    msg.msg_iov = iov2;
+    msg.msg_iovlen = 2;
+  }
+#endif
+
+  if (s->flags & SKF_PKTINFO)
+    sk_prepare_cmsgs(s, &msg, cmsg_buf, sizeof(cmsg_buf));
+
+  return CSP_sendmsg(s->fd, &msg, flags);
+}
+
+static inline int
+sk_recvmsg(sock *s)
+{
+  struct iovec iov = {s->rbuf, s->rbsize};
+  byte cmsg_buf[CMSG_RX_SPACE];
+  sockaddr src;
+
+  struct msghdr msg = {
+    .msg_name = &src.sa,
+    .msg_namelen = sizeof(src), // XXXX ??
+    .msg_iov = &iov,
+    .msg_iovlen = 1,
+    .msg_control = cmsg_buf,
+    .msg_controllen = sizeof(cmsg_buf),
+    .msg_flags = 0
+  };
+
+  int rv = CSP_recvmsg(s->fd, &msg, 0);
+  if (rv < 0)
+    return rv;
+
+  //ifdef IPV4
+  //  if (cf_type == SK_IP)
+  //    rv = ipv4_skip_header(pbuf, rv);
+  //endif
+
+  sockaddr_read(&src, s->af, &s->faddr, NULL, &s->fport);
+  sk_process_cmsgs(s, &msg);
+
+  if (msg.msg_flags & MSG_TRUNC)
+    s->flags |= SKF_TRUNCATED;
+  else
+    s->flags &= ~SKF_TRUNCATED;
+
+  return rv;
+}
+
+
+static inline void reset_tx_buffer(sock *s) { s->ttx = s->tpos = s->tbuf; }
+
+static int
+sk_maybe_write(sock *s)
+{
+  int e;
+
+  switch (s->type)
+  {
+  case SK_TCP:
+  case SK_MAGIC:
+  case SK_UNIX:
+    while (s->ttx != s->tpos)
+    {
+      e = CSP_write(s->fd, s->ttx, s->tpos - s->ttx);
+
+      if (e < 0)
+      {
+	if (errno != EINTR && errno != EAGAIN)
+	{
+	  reset_tx_buffer(s);
+	  /* EPIPE is just a connection close notification during TX */
+	  s->err_hook(s, (errno != EPIPE) ? errno : 0);
+	  return -1;
+	}
+	return 0;
+      }
+      s->ttx += e;
+    }
+    reset_tx_buffer(s);
+    return 1;
+
+  case SK_UDP:
+  case SK_IP:
+    {
+      if (s->tbuf == s->tpos)
+	return 1;
+
+      e = sk_sendmsg(s);
+
+      if (e < 0)
+      {
+	if (errno != EINTR && errno != EAGAIN)
+	{
+	  reset_tx_buffer(s);
+	  s->err_hook(s, errno);
+	  return -1;
+	}
+
+	if (!s->tx_hook)
+	  reset_tx_buffer(s);
+	return 0;
+      }
+      reset_tx_buffer(s);
+      return 1;
+    }
+  default:
+    bug("sk_maybe_write: unknown socket type %d", s->type);
+  }
+}
+
+int
+sk_rx_ready(sock *s)
+{
+  fd_set rd, wr;
+  struct timeval timo;
+  int rv;
+
+  FD_ZERO(&rd);
+  FD_ZERO(&wr);
+  FD_SET(s->fd, &rd);
+
+  timo.tv_sec = 0;
+  timo.tv_usec = 0;
+
+ redo:
+  rv = CSP_select(s->fd+1, &rd, &wr, NULL, &timo);
+
+  if ((rv < 0) && (errno == EINTR || errno == EAGAIN))
+    goto redo;
+
+  return rv;
+}
+/**
+ * sk_send - send data to a socket
+ * @s: socket
+ * @len: number of bytes to send
+ *
+ * This function sends @len bytes of data prepared in the
+ * transmit buffer of the socket @s to the network connection.
+ * If the packet can be sent immediately, it does so and returns
+ * 1, else it queues the packet for later processing, returns 0
+ * and calls the @tx_hook of the socket when the tranmission
+ * takes place.
+ */
+int
+sk_send(sock *s, unsigned len)
+{
+  s->ttx = s->tbuf;
+  s->tpos = s->tbuf + len;
+  return sk_maybe_write(s);
+}
+
+/**
+ * sk_send_to - send data to a specific destination
+ * @s: socket
+ * @len: number of bytes to send
+ * @addr: IP address to send the packet to
+ * @port: port to send the packet to
+ *
+ * This is a sk_send() replacement for connection-less packet sockets
+ * which allows destination of the packet to be chosen dynamically.
+ * Raw IP sockets should use 0 for @port.
+ */
+int
+sk_send_to(sock *s, unsigned len, ip_addr addr, unsigned port)
+{
+  s->daddr = addr;
+  if (port)
+    s->dport = port;
+
+  s->ttx = s->tbuf;
+  s->tpos = s->tbuf + len;
+  return sk_maybe_write(s);
+}
+
+/*
+int
+sk_send_full(sock *s, unsigned len, struct iface *ifa,
+	     ip_addr saddr, ip_addr daddr, unsigned dport)
+{
+  s->iface = ifa;
+  s->saddr = saddr;
+  s->daddr = daddr;
+  s->dport = dport;
+  s->ttx = s->tbuf;
+  s->tpos = s->tbuf + len;
+  return sk_maybe_write(s);
+}
+*/
+
+ /* sk_read() and sk_write() are called from BFD's event loop */
+
+int
+sk_read(sock *s, int revents UNUSED)
+{
+  switch (s->type)
+  {
+  case SK_TCP_PASSIVE:
+    return sk_passive_connected(s, SK_TCP);
+
+  case SK_UNIX_PASSIVE:
+    return sk_passive_connected(s, SK_UNIX);
+
+  case SK_TCP:
+  case SK_UNIX:
+    {
+      int c = CSP_read(s->fd, s->rpos, s->rbuf + s->rbsize - s->rpos);
+
+      if (c < 0)
+      {
+	if (errno != EINTR && errno != EAGAIN)
+	  s->err_hook(s, errno);
+      }
+      else if (!c)
+	s->err_hook(s, 0);
+      else
+      {
+	s->rpos += c;
+	if (s->rx_hook(s, s->rpos - s->rbuf))
+	{
+	  /* We need to be careful since the socket could have been deleted by the hook */
+	  if (current_sock == s)
+	    s->rpos = s->rbuf;
+	}
+	return 1;
+      }
+      return 0;
+    }
+
+  case SK_MAGIC:
+    return s->rx_hook(s, 0);
+
+  default:
+    {
+      int e = sk_recvmsg(s);
+
+      if (e < 0)
+      {
+	if (errno != EINTR && errno != EAGAIN)
+	  s->err_hook(s, errno);
+	return 0;
+      }
+
+      s->rpos = s->rbuf + e;
+      s->rx_hook(s, e);
+      return 1;
+    }
+  }
+}
+
+int
+sk_write(sock *s)
+{
+  switch (s->type)
+  {
+  case SK_TCP_ACTIVE:
+    {
+      sockaddr sa;
+      sockaddr_fill(&sa, s->af, s->daddr, s->iface, s->dport);
+
+      if (connect(s->fd, &sa.sa, SA_LEN(sa)) >= 0 || errno == EISCONN)
+	sk_tcp_connected(s);
+      else if (errno != EINTR && errno != EAGAIN && errno != EINPROGRESS)
+	s->err_hook(s, errno);
+      return 0;
+    }
+
+  default:
+    if (s->ttx != s->tpos && sk_maybe_write(s) > 0)
+    {
+      if (s->tx_hook)
+	s->tx_hook(s);
+      return 1;
+    }
+    return 0;
+  }
+}
+
+void
+sk_dump_all(void)
+{
+  node *n;
+  sock *s;
+
+  debug("Open sockets:\n");
+  WALK_LIST(n, sock_list)
+  {
+    s = SKIP_BACK(sock, n, n);
+    debug("%p ", s);
+    sk_dump(&s->r);
+  }
+  debug("\n");
+}
+
+
+/*
+ *	Internal event log and watchdog
+ */
+
+#define EVENT_LOG_LENGTH 32
+
+struct event_log_entry
+{
+  void *hook;
+  void *data;
+  btime timestamp;
+  btime duration;
+};
+
+static struct event_log_entry event_log[EVENT_LOG_LENGTH];
+static struct event_log_entry *event_open;
+static int event_log_pos, event_log_num, watchdog_active;
+static btime last_time;
+static btime loop_time;
+
+static void
+io_update_time(void)
+{
+  struct timespec ts;
+  int rv;
+
+  if (!clock_monotonic_available)
+    return;
+
+  /*
+   * This is third time-tracking procedure (after update_times() above and
+   * times_update() in BFD), dedicated to internal event log and latency
+   * tracking. Hopefully, we consolidate these sometimes.
+   */
+
+  rv = clock_gettime(CLOCK_MONOTONIC, &ts);
+  if (rv < 0)
+    die("clock_gettime: %m");
+
+  last_time = ((s64) ts.tv_sec S) + (ts.tv_nsec / 1000);
+
+  if (event_open)
+  {
+    event_open->duration = last_time - event_open->timestamp;
+
+    if (event_open->duration > config->latency_limit)
+      log(L_WARN "Event 0x%p 0x%p took %d ms",
+	  event_open->hook, event_open->data, (int) (event_open->duration TO_MS));
+
+    event_open = NULL;
+  }
+}
+
+/**
+ * io_log_event - mark approaching event into event log
+ * @hook: event hook address
+ * @data: event data address
+ *
+ * Store info (hook, data, timestamp) about the following internal event into
+ * a circular event log (@event_log). When latency tracking is enabled, the log
+ * entry is kept open (in @event_open) so the duration can be filled later.
+ */
+void
+io_log_event(void *hook, void *data)
+{
+  if (config->latency_debug)
+    io_update_time();
+
+  struct event_log_entry *en = event_log + event_log_pos;
+
+  en->hook = hook;
+  en->data = data;
+  en->timestamp = last_time;
+  en->duration = 0;
+
+  event_log_num++;
+  event_log_pos++;
+  event_log_pos %= EVENT_LOG_LENGTH;
+
+  event_open = config->latency_debug ? en : NULL;
+}
+
+static inline void
+io_close_event(void)
+{
+  if (event_open)
+    io_update_time();
+}
+
+void
+io_log_dump(void)
+{
+  int i;
+
+  log(L_DEBUG "Event log:");
+  for (i = 0; i < EVENT_LOG_LENGTH; i++)
+  {
+    struct event_log_entry *en = event_log + (event_log_pos + i) % EVENT_LOG_LENGTH;
+    if (en->hook)
+      log(L_DEBUG "  Event 0x%p 0x%p at %8d for %d ms", en->hook, en->data,
+	  (int) ((last_time - en->timestamp) TO_MS), (int) (en->duration TO_MS));
+  }
+}
+
+void
+watchdog_sigalrm(int sig UNUSED)
+{
+  /* Update last_time and duration, but skip latency check */
+  config->latency_limit = 0xffffffff;
+  io_update_time();
+
+  /* We want core dump */
+  abort();
+}
+
+static inline void
+watchdog_start1(void)
+{
+  io_update_time();
+
+  loop_time = last_time;
+}
+
+static inline void
+watchdog_start(void)
+{
+  io_update_time();
+
+  loop_time = last_time;
+  event_log_num = 0;
+
+  if (config->watchdog_timeout)
+  {
+    alarm(config->watchdog_timeout);
+    watchdog_active = 1;
+  }
+}
+
+static inline void
+watchdog_stop(void)
+{
+  io_update_time();
+
+  if (watchdog_active)
+  {
+    alarm(0);
+    watchdog_active = 0;
+  }
+
+  btime duration = last_time - loop_time;
+  if (duration > config->watchdog_warning)
+    log(L_WARN "I/O loop cycle took %d ms for %d events",
+	(int) (duration TO_MS), event_log_num);
+}
+
+
+/*
+ *	Main I/O Loop
+ */
+
+volatile int async_config_flag;		/* Asynchronous reconfiguration/dump scheduled */
+volatile int async_dump_flag;
+volatile int async_shutdown_flag;
+
+void
+io_init(void)
+{
+  init_list(&near_timers);
+  init_list(&far_timers);
+  init_list(&sock_list);
+  init_list(&global_event_list);
+  krt_io_init();
+  init_times();
+  update_times();
+  boot_time = now;
+  srandom((int) now_real);
+}
+
+static int short_loops = 0;
+#define SHORT_LOOP_MAX 10
+
+void
+io_loop(void)
+{
+
+  fd_set rd, wr;
+  struct timeval timo;
+  time_t tout;
+  int hi, events;
+  sock *s;
+  node *n;
+
+  sock_recalc_fdsets_p = 1;
+  watchdog_start1();
+  for(;;)
+    {
+      events = ev_run_list(&global_event_list);
+      update_times();
+      tout = tm_first_shot();
+      if (tout <= now)
+	{
+	  tm_shot();
+	  continue;
+	}
+      timo.tv_sec = events ? 0 : MIN(tout - now, 3);
+      timo.tv_usec = 0;
+      io_close_event();
+
+      if (sock_recalc_fdsets_p)
+      {
+          sock_recalc_fdsets_p = 0;
+          FD_ZERO(&rd);
+          FD_ZERO(&wr);
+      }
+
+      hi = 0;
+      WALK_LIST(n, sock_list)
+	{
+	  s = SKIP_BACK(sock, n, n);
+	  if (s->rx_hook)
+	    {
+	      FD_SET(s->fd, &rd);
+	      if (s->fd > hi)
+	          hi = s->fd;
+	    }
+	  else
+	      FD_CLR(s->fd, &rd);
+	  if (s->tx_hook && s->ttx != s->tpos)
+	    {
+          FD_SET(s->fd, &wr);
+          if (s->fd > hi)
+              hi = s->fd;
+	    }
+	  else
+	    FD_CLR(s->fd, &wr);
+	}
+
+      /*
+       * Yes, this is racy. But even if the signal comes before this test
+       * and entering select(), it gets caught on the next timer tick.
+       */
+
+      if (async_config_flag)
+	{
+	  io_log_event(async_config, NULL);
+	  async_config();
+	  async_config_flag = 0;
+	  continue;
+	}
+      if (async_dump_flag)
+	{
+	  io_log_event(async_dump, NULL);
+	  async_dump();
+	  async_dump_flag = 0;
+	  continue;
+	}
+      if (async_shutdown_flag)
+	{
+	  io_log_event(async_shutdown, NULL);
+	  async_shutdown();
+	  async_shutdown_flag = 0;
+	  continue;
+	}
+
+      /* And finally enter select() to find active sockets */
+      watchdog_stop();
+      hi = CSP_select(hi+1, &rd, &wr, NULL, &timo);
+      watchdog_start();
+
+      if (hi < 0)
+	{
+	  if (errno == EINTR || errno == EAGAIN)
+	    continue;
+	  die("select: %m");
+	}
+      if (hi)
+	{
+	  /* guaranteed to be non-empty */
+	  current_sock = SKIP_BACK(sock, n, HEAD(sock_list));
+
+	  while (current_sock)
+	    {
+	      sock *s = current_sock;
+	      int e;
+	      int steps;
+
+	      steps = MAX_STEPS;
+
+	      if ((s->type >= SK_MAGIC) && FD_ISSET(s->fd, &rd) && s->rx_hook)
+		do
+		  {
+		    steps--;
+		    io_log_event(s->rx_hook, s->data);
+		    e = sk_read(s, 0);
+		    if (s != current_sock)
+		      goto next;
+		  }
+		while (e && s->rx_hook && steps);
+
+	      steps = MAX_STEPS;
+	      if (FD_ISSET(s->fd, &wr))
+		do
+		  {
+		    steps--;
+		    io_log_event(s->tx_hook, s->data);
+		    e = sk_write(s);
+		    if (s != current_sock)
+		      goto next;
+		  }
+		while (e && steps);
+	      current_sock = sk_next(s);
+	    next: ;
+	    }
+
+	  short_loops++;
+	  if (events && (short_loops < SHORT_LOOP_MAX))
+	    continue;
+	  short_loops = 0;
+
+	  int count = 0;
+	  current_sock = stored_sock;
+	  if (current_sock == NULL)
+	    current_sock = SKIP_BACK(sock, n, HEAD(sock_list));
+
+	  while (current_sock && count < MAX_RX_STEPS)
+	    {
+	      sock *s = current_sock;
+
+	      if ((s->type < SK_MAGIC) && FD_ISSET(s->fd, &rd) && s->rx_hook)
+		{
+		  count++;
+		  io_log_event(s->rx_hook, s->data);
+		  sk_read(s, 0);
+		  if (s != current_sock)
+		    goto next2;
+		}
+
+	      current_sock = sk_next(s);
+	    next2: ;
+	    }
+
+	  stored_sock = current_sock;
+	}
+    }
+}
+
+void
+test_old_bird(char *path)
+{
+  int fd;
+  struct sockaddr_un sa;
+
+  fd = socket(AF_UNIX, SOCK_STREAM, 0);
+  if (fd < 0)
+    die("Cannot create socket: %m");
+  if (strlen(path) >= sizeof(sa.sun_path))
+    die("Socket path too long");
+  bzero(&sa, sizeof(sa));
+  sa.sun_family = AF_UNIX;
+  strcpy(sa.sun_path, path);
+  if (connect(fd, (struct sockaddr *) &sa, SUN_LEN(&sa)) == 0)
+    die("I found another BIRD running.");
+  close(fd);
+}
diff --git a/sysdep/click/log.c b/sysdep/click/log.c
new file mode 100644
index 00000000..e488cc6a
--- /dev/null
+++ b/sysdep/click/log.c
@@ -0,0 +1,367 @@
+/*
+ *	BIRD Library -- Logging Functions
+ *
+ *	(c) 1998--2000 Martin Mares <mj@ucw.cz>
+ *      (c) 2004       Ondrej Filip <feela@network.cz>
+ *      (c) 2014--2017 Cisco Systems, Inc.
+ *
+ *	Can be freely distributed and used under the terms of the GNU GPL.
+ */
+
+/**
+ * DOC: Logging
+ *
+ * The Logging module offers a simple set of functions for writing
+ * messages to system logs and to the debug output. Message classes
+ * used by this module are described in |birdlib.h| and also in the
+ * user's manual.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <time.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include "nest/bird.h"
+#include "nest/cli.h"
+#include "conf/conf.h"
+#include "lib/string.h"
+#include "lib/lists.h"
+#include "lib/unix.h"
+#include <sockproxy.h>
+
+static FILE *dbgf;
+static list *current_log_list;
+static char *current_syslog_name; /* NULL -> syslog closed */
+
+
+#ifdef USE_PTHREADS
+
+#include <pthread.h>
+
+static pthread_mutex_t log_mutex;
+static inline void log_lock(void) { pthread_mutex_lock(&log_mutex); }
+static inline void log_unlock(void) { pthread_mutex_unlock(&log_mutex); }
+
+static pthread_t main_thread;
+void main_thread_init(void) { main_thread = pthread_self(); }
+static int main_thread_self(void) { return pthread_equal(pthread_self(), main_thread); }
+
+#else
+
+static inline void log_lock(void) {  }
+static inline void log_unlock(void) {  }
+void main_thread_init(void) { }
+static int main_thread_self(void) { return 1; }
+
+#endif
+
+
+#ifdef HAVE_SYSLOG_H
+#include <sys/syslog.h>
+
+static int syslog_priorities[] = {
+  LOG_DEBUG,
+  LOG_DEBUG,
+  LOG_DEBUG,
+  LOG_INFO,
+  LOG_ERR,
+  LOG_WARNING,
+  LOG_ERR,
+  LOG_ERR,
+  LOG_CRIT,
+  LOG_CRIT
+};
+#endif
+
+static char *class_names[] = {
+  "???",
+  "DBG",
+  "TRACE",
+  "INFO",
+  "RMT",
+  "WARN",
+  "ERR",
+  "AUTH",
+  "FATAL",
+  "BUG"
+};
+
+
+/**
+ * log_commit - commit a log message
+ * @class: message class information (%L_DEBUG to %L_BUG, see |lib/birdlib.h|)
+ * @buf: message to write
+ *
+ * This function writes a message prepared in the log buffer to the
+ * log file (as specified in the configuration). The log buffer is
+ * reset after that. The log message is a full line, log_commit()
+ * terminates it.
+ *
+ * The message class is an integer, not a first char of a string like
+ * in log(), so it should be written like *L_INFO.
+ */
+void
+log_commit(int class, buffer *buf)
+{
+  struct log_config *l;
+
+  if (buf->pos == buf->end)
+    strcpy(buf->end - 100, " ... <too long>");
+
+  log_lock();
+  WALK_LIST(l, *current_log_list)
+    {
+      if (!(l->mask & (1 << class)))
+	continue;
+      if (l->fh)
+	{
+	  if (l->terminal_flag)
+	    fputs("bird: ", l->fh);
+	  else
+	    {
+	      byte tbuf[TM_DATETIME_BUFFER_SIZE];
+	      tm_format_datetime(tbuf, &config->tf_log, now);
+	      fprintf(l->fh, "%s <%s> ", tbuf, class_names[class]);
+	    }
+	  fputs(buf->start, l->fh);
+	  fputc('\n', l->fh);
+	  fflush(l->fh);
+	}
+#ifdef HAVE_SYSLOG_H
+      else
+	syslog(syslog_priorities[class], "%s", buf->start);
+#endif
+    }
+  log_unlock();
+
+  /* cli_echo is not thread-safe, so call it just from the main thread */
+  if (main_thread_self())
+    cli_echo(class, buf->start);
+
+  buf->pos = buf->start;
+}
+
+int buffer_vprint(buffer *buf, const char *fmt, va_list args);
+
+static void
+vlog(int class, const char *msg, va_list args)
+{
+  buffer buf;
+  LOG_BUFFER_INIT(buf);
+  buffer_vprint(&buf, msg, args);
+  log_commit(class, &buf);
+}
+
+
+/**
+ * log - log a message
+ * @msg: printf-like formatting string with message class information
+ * prepended (%L_DEBUG to %L_BUG, see |lib/birdlib.h|)
+ *
+ * This function formats a message according to the format string @msg
+ * and writes it to the corresponding log file (as specified in the
+ * configuration). Please note that the message is automatically
+ * formatted as a full line, no need to include |\n| inside.
+ * It is essentially a sequence of log_reset(), logn() and log_commit().
+ */
+void
+log_msg(const char *msg, ...)
+{
+  int class = 1;
+  va_list args;
+
+  va_start(args, msg);
+  if (*msg >= 1 && *msg <= 8)
+    class = *msg++;
+  vlog(class, msg, args);
+  va_end(args);
+}
+
+void
+log_rl(struct tbf *f, const char *msg, ...)
+{
+  int last_hit = f->mark;
+  int class = 1;
+  va_list args;
+
+  /* Rate limiting is a bit tricky here as it also logs '...' during the first hit */
+  if (tbf_limit(f) && last_hit)
+    return;
+
+  if (*msg >= 1 && *msg <= 8)
+    class = *msg++;
+
+  va_start(args, msg);
+  vlog(class, (f->mark ? "..." : msg), args);
+  va_end(args);
+}
+
+/**
+ * bug - report an internal error
+ * @msg: a printf-like error message
+ *
+ * This function logs an internal error and aborts execution
+ * of the program.
+ */
+void
+bug(const char *msg, ...)
+{
+  va_list args;
+
+  va_start(args, msg);
+  vlog(L_BUG[0], msg, args);
+  va_end(args);
+  abort();
+}
+
+/**
+ * bug - report a fatal error
+ * @msg: a printf-like error message
+ *
+ * This function logs a fatal error and aborts execution
+ * of the program.
+ */
+void
+die(const char *msg, ...)
+{
+  va_list args;
+
+  va_start(args, msg);
+  vlog(L_FATAL[0], msg, args);
+  va_end(args);
+  exit(1);
+}
+
+/**
+ * debug - write to debug output
+ * @msg: a printf-like message
+ *
+ * This function formats the message @msg and prints it out
+ * to the debugging output. No newline character is appended.
+ */
+void
+debug(const char *msg, ...)
+{
+#define MAX_DEBUG_BUFSIZE       65536
+  va_list args;
+  static uint bufsize = 4096;
+  static char *buf = NULL;
+
+  if (!buf)
+    buf = mb_alloc(&root_pool, bufsize);
+
+  va_start(args, msg);
+  if (dbgf)
+    {
+      while (bvsnprintf(buf, bufsize, msg, args) < 0)
+        if (bufsize >= MAX_DEBUG_BUFSIZE)
+          bug("Extremely long debug output, split it.");
+        else
+          buf = mb_realloc(buf, (bufsize *= 2));
+
+      fputs(buf, dbgf);
+    }
+  va_end(args);
+}
+
+static list *
+default_log_list(int debug, int init, char **syslog_name)
+{
+  static list init_log_list;
+  init_list(&init_log_list);
+  *syslog_name = NULL;
+
+#ifdef HAVE_SYSLOG_H
+  if (!debug)
+    {
+      static struct log_config lc_syslog = { .mask = ~0 };
+      add_tail(&init_log_list, &lc_syslog.n);
+      *syslog_name = bird_name;
+      if (!init)
+	return &init_log_list;
+    }
+#endif
+
+  static struct log_config lc_stderr = { .mask = ~0, .terminal_flag = 1 };
+  lc_stderr.fh = stderr;
+  add_tail(&init_log_list, &lc_stderr.n);
+  return &init_log_list;
+}
+
+void
+log_switch(int debug, list *l, char *new_syslog_name)
+{
+  if (!l || EMPTY_LIST(*l))
+    l = default_log_list(debug, !l, &new_syslog_name);
+
+  log_lock();
+
+  current_log_list = l;
+
+#ifdef HAVE_SYSLOG_H
+  if (current_syslog_name && new_syslog_name &&
+      !strcmp(current_syslog_name, new_syslog_name))
+    goto done;
+
+  if (current_syslog_name)
+  {
+    closelog();
+    xfree(current_syslog_name);
+    current_syslog_name = NULL;
+  }
+
+  if (new_syslog_name)
+  {
+    current_syslog_name = xstrdup(new_syslog_name);
+    openlog(current_syslog_name, LOG_CONS | LOG_NDELAY, LOG_DAEMON);
+  }
+#endif
+
+done:
+  log_unlock();
+}
+
+
+
+void
+log_init_debug(char *f)
+{
+  if (dbgf && dbgf != stderr)
+    fclose(dbgf);
+  if (!f)
+    dbgf = NULL;
+  else if (!*f)
+    dbgf = stderr;
+  else if (!(dbgf = fopen(f, "a")))
+  {
+    /* Cannot use die() nor log() here, logging is not yet initialized */
+    fprintf(stderr, "bird: Unable to open debug file %s: %s\n", f, strerror(errno));
+    exit(1);
+  }
+  if (dbgf)
+    setvbuf(dbgf, NULL, _IONBF, 0);
+}
+
+void
+sockproxy_debug(enum csp_debug_class class, const char* format, va_list va)
+{
+  int log_class;
+  switch (class) {
+  case CSP_DEBUG_WARN:
+      log_class = L_WARN[0];
+      break;
+  case CSP_DEBUG_ERR:
+      log_class = L_ERR[0];
+      break;
+  case CSP_DEBUG_CRIT:
+      log_class = L_FATAL[0];
+      break;
+  default:
+      log_class = L_DEBUG[0];
+      break;
+  }
+  vlog(log_class, format, va);
+}
diff --git a/sysdep/click/main.c b/sysdep/click/main.c
new file mode 100644
index 00000000..be5e8f3b
--- /dev/null
+++ b/sysdep/click/main.c
@@ -0,0 +1,983 @@
+/*
+ *	BIRD Internet Routing Daemon -- Click Entry Point
+ *
+ *	(c) 1998--2000 Martin Mares <mj@ucw.cz>
+ *      (c) 2014--2017 Cisco Systems, Inc.
+ *
+ *	Can be freely distributed and used under the terms of the GNU GPL.
+ */
+
+#undef LOCAL_DEBUG
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <signal.h>
+#include <pwd.h>
+#include <grp.h>
+#include <sys/stat.h>
+#include <libgen.h>
+
+#include "nest/bird.h"
+#include "lib/lists.h"
+#include "lib/resource.h"
+#include "lib/socket.h"
+#include "lib/event.h"
+#include "lib/string.h"
+#include "nest/route.h"
+#include "nest/protocol.h"
+#include "nest/iface.h"
+#include "nest/cli.h"
+#include "nest/locks.h"
+#include "conf/conf.h"
+#include "filter/filter.h"
+
+#include "unix.h"
+#include "krt.h"
+#include "kif.h"
+
+#include <sockproxy.h>
+
+/*
+ *	Debugging
+ */
+
+#ifdef DEBUGGING
+static int debug_flag = 1;
+#else
+static int debug_flag = 0;
+#endif
+
+void
+async_dump(void)
+{
+  debug("INTERNAL STATE DUMP\n\n");
+
+  rdump(&root_pool);
+  sk_dump_all();
+  tm_dump_all();
+  if_dump_all();
+  neigh_dump_all();
+  rta_dump_all();
+  rt_dump_all();
+  protos_dump_all();
+
+  debug("\n");
+}
+
+/*
+ *	Dropping privileges
+ */
+
+#ifdef CONFIG_RESTRICTED_PRIVILEGES
+#include "lib/syspriv.h"
+#else
+
+static inline void
+drop_uid(uid_t uid UNUSED)
+{
+  die("Cannot change user on this platform");
+}
+
+#endif
+
+static inline void
+drop_gid(gid_t gid)
+{
+  if (setgid(gid) < 0)
+    die("setgid: %m");
+
+  if (setgroups(0, NULL) < 0)
+    die("setgroups: %m");
+}
+
+/*
+ *	Reading the Configuration
+ */
+
+#ifdef PATH_IPROUTE_DIR
+
+static inline void
+add_num_const(char *name, int val)
+{
+  struct symbol *s = cf_get_symbol(name);
+  s->class = SYM_CONSTANT | T_INT;
+  s->def = cfg_allocz(sizeof(struct f_val));
+  SYM_TYPE(s) = T_INT;
+  SYM_VAL(s).i = val;
+}
+
+/* the code of read_iproute_table() is based on
+   rtnl_tab_initialize() from iproute2 package */
+static void
+read_iproute_table(char *file, char *prefix, int max)
+{
+  char buf[512], namebuf[512];
+  char *name;
+  int val;
+  FILE *fp;
+
+  strcpy(namebuf, prefix);
+  name = namebuf + strlen(prefix);
+
+  fp = fopen(file, "r");
+  if (!fp)
+    return;
+
+  while (fgets(buf, sizeof(buf), fp))
+  {
+    char *p = buf;
+
+    while (*p == ' ' || *p == '\t')
+      p++;
+
+    if (*p == '#' || *p == '\n' || *p == 0)
+      continue;
+   
+    if (sscanf(p, "0x%x %s\n", &val, name) != 2 &&
+	sscanf(p, "0x%x %s #", &val, name) != 2 &&
+	sscanf(p, "%d %s\n", &val, name) != 2 &&
+	sscanf(p, "%d %s #", &val, name) != 2)
+      continue;
+
+    if (val < 0 || val > max)
+      continue;
+
+    for(p = name; *p; p++)
+      if ((*p < 'a' || *p > 'z') && (*p < '0' || *p > '9') && (*p != '_'))
+	*p = '_';
+
+    add_num_const(namebuf, val);
+  }
+
+  fclose(fp);
+}
+
+#endif // PATH_IPROUTE_DIR
+
+
+static char *config_name = PATH_CONFIG_FILE;
+
+static int
+cf_read(byte *dest, uint len, int fd)
+{
+  int l = read(fd, dest, len);
+  if (l < 0)
+    cf_error("Read error");
+  return l;
+}
+
+void
+sysdep_preconfig(struct config *c)
+{
+  init_list(&c->logfiles);
+
+  c->latency_limit = UNIX_DEFAULT_LATENCY_LIMIT;
+  c->watchdog_warning = UNIX_DEFAULT_WATCHDOG_WARNING;
+
+#ifdef PATH_IPROUTE_DIR
+  read_iproute_table(PATH_IPROUTE_DIR "/rt_protos", "ipp_", 256);
+  read_iproute_table(PATH_IPROUTE_DIR "/rt_realms", "ipr_", 256);
+  read_iproute_table(PATH_IPROUTE_DIR "/rt_scopes", "ips_", 256);
+  read_iproute_table(PATH_IPROUTE_DIR "/rt_tables", "ipt_", 256);
+#endif
+}
+
+int
+sysdep_commit(struct config *new, struct config *old UNUSED)
+{
+  log_switch(debug_flag, &new->logfiles, new->syslog_name);
+  return 0;
+}
+
+static int
+unix_read_config(struct config **cp, char *name)
+{
+  struct config *conf = config_alloc(name);
+  int ret;
+
+  *cp = conf;
+  conf->file_fd = open(name, O_RDONLY);
+  if (conf->file_fd < 0)
+    return 0;
+  cf_read_hook = cf_read;
+  ret = config_parse(conf);
+  close(conf->file_fd);
+  return ret;
+}
+
+static struct config *
+read_config(void)
+{
+  struct config *conf;
+
+  if (!unix_read_config(&conf, config_name))
+    {
+      if (conf->err_msg)
+	die("%s:%d:%d %s", conf->err_file_name, conf->err_lino, conf->err_chno, conf->err_msg);
+      else
+	die("Unable to open configuration file %s: %m", config_name);
+    }
+
+  return conf;
+}
+
+void
+async_config(void)
+{
+  struct config *conf;
+
+  log(L_INFO "Reconfiguration requested by SIGHUP");
+  if (!unix_read_config(&conf, config_name))
+    {
+      if (conf->err_msg)
+	log(L_ERR "%s:%d:%d %s", conf->err_file_name, conf->err_lino, conf->err_chno, conf->err_msg);
+      else
+	log(L_ERR "Unable to open configuration file %s: %m", config_name);
+      config_free(conf);
+    }
+  else
+    config_commit(conf, RECONFIG_HARD, 0);
+}
+
+static struct config *
+cmd_read_config(char *name)
+{
+  struct config *conf;
+
+  if (!name)
+    name = config_name;
+
+  cli_msg(-2, "Reading configuration from %s", name);
+  if (!unix_read_config(&conf, name))
+    {
+      if (conf->err_msg)
+	cli_msg(8002, "%s:%d:%d %s", conf->err_file_name, conf->err_lino, conf->err_chno, conf->err_msg);
+      else
+	cli_msg(8002, "%s: %m", name);
+      config_free(conf);
+      conf = NULL;
+    }
+
+  return conf;
+}
+
+void
+cmd_check_config(char *name)
+{
+  struct config *conf = cmd_read_config(name);
+  if (!conf)
+    return;
+
+  cli_msg(20, "Configuration OK");
+  config_free(conf);
+}
+
+static void
+cmd_reconfig_msg(int r)
+{
+  switch (r)
+    {
+    case CONF_DONE:	cli_msg( 3, "Reconfigured"); break;
+    case CONF_PROGRESS: cli_msg( 4, "Reconfiguration in progress"); break;
+    case CONF_QUEUED:	cli_msg( 5, "Reconfiguration already in progress, queueing new config"); break;
+    case CONF_UNQUEUED:	cli_msg(17, "Reconfiguration already in progress, removing queued config"); break;
+    case CONF_CONFIRM:	cli_msg(18, "Reconfiguration confirmed"); break;
+    case CONF_SHUTDOWN:	cli_msg( 6, "Reconfiguration ignored, shutting down"); break;
+    case CONF_NOTHING:	cli_msg(19, "Nothing to do"); break;
+    default:		break;
+    }
+}
+
+/* Hack for scheduled undo notification */
+cli *cmd_reconfig_stored_cli;
+
+void
+cmd_reconfig_undo_notify(void)
+{
+  if (cmd_reconfig_stored_cli)
+    {
+      cli *c = cmd_reconfig_stored_cli;
+      cli_printf(c, CLI_ASYNC_CODE, "Config timeout expired, starting undo");
+      cli_write_trigger(c);
+    }
+}
+
+void
+cmd_reconfig(char *name, int type, int timeout)
+{
+  if (cli_access_restricted())
+    return;
+
+  struct config *conf = cmd_read_config(name);
+  if (!conf)
+    return;
+
+  int r = config_commit(conf, type, timeout);
+
+  if ((r >= 0) && (timeout > 0))
+    {
+      cmd_reconfig_stored_cli = this_cli;
+      cli_msg(-22, "Undo scheduled in %d s", timeout);
+    }
+
+  cmd_reconfig_msg(r);
+}
+
+void
+cmd_reconfig_confirm(void)
+{
+  if (cli_access_restricted())
+    return;
+
+  int r = config_confirm();
+  cmd_reconfig_msg(r);
+}
+
+void
+cmd_reconfig_undo(void)
+{
+  if (cli_access_restricted())
+    return;
+
+  cli_msg(-21, "Undo requested");
+
+  int r = config_undo();
+  cmd_reconfig_msg(r);
+}
+
+static int
+intcompar(const void* int1, const void* int2)
+{
+    return (*(int*)int1 - *(int*)int2);
+}
+
+void
+cmd_sockproxy_stats(void)
+{
+  int count = 0;
+
+  struct sockproxy_stats stats;
+
+  if (CSP_get_stats(&stats) < 0)
+    {
+      cli_msg(8, "Error reading stats");
+      return;
+    }
+
+  cli_msg(-1201, "RX Pkts            : %u", stats.rx_packets);
+  cli_msg(-1201, "RX Undelivered Pkts: %u", stats.rx_undelivered_packets);
+  cli_msg(-1201, "TX Pkts            : %u", stats.tx_packets);
+  cli_msg(-1201, "");
+
+  if (CSP_get_open_sockets(NULL, &count) < 0 && errno != ENOSPC)
+    {
+      cli_msg(8, "Error reading number of sockets");
+      return;
+    }
+
+  int fds[count];
+  if (CSP_get_open_sockets(fds, &count) < 0)
+    {
+      cli_msg(8, "Error reading sockets");
+      return;
+    }
+
+  qsort(fds, count, sizeof(int), intcompar);
+
+  cli_msg(-1201, "%-5s\t%-10s\t%-15s\t%-15s\t%-15s\t%-15s", "FD", "Device", "RX Pkts",
+          "RX Drop Pkts", "RX Queued", "TX Pkts");
+  int i;
+  for (i = 0; i < count; i++)
+    {
+      struct sockproxy_socket_stats sockstats;
+      if (CSP_get_socket_stats(fds[i], &sockstats) < 0)
+        {
+          cli_msg(8, "Error reading stats");
+          return;
+        }
+
+      char device[IFNAMSIZ];
+      socklen_t optlen = IFNAMSIZ;
+      if (CSP_getsockopt(fds[i], SOL_SOCKET, SO_BINDTODEVICE, device, &optlen) < 0)
+        {
+          cli_msg(8, "Error getting device");
+          return;
+        }
+
+      cli_msg(-1201, "%-5d\t%-10s\t%-15u\t%-15u\t%-15u\t%-15u", fds[i], device, sockstats.rx_packets,
+              sockstats.rx_dropped_packets, sockstats.rx_waiting, sockstats.tx_packets);
+
+    }
+  cli_msg(0, "");
+}
+
+void cmd_sockproxy_reset_stats(void)
+{
+  if (CSP_reset_stats() < 0)
+    cli_msg(8, "Error resetting stats");
+  else
+    cli_msg(0, "");
+}
+
+/*
+ *	Command-Line Interface
+ */
+
+static sock *cli_sk;
+static char *path_control_socket = PATH_CONTROL_SOCKET;
+
+
+static void
+cli_write(cli *c)
+{
+  sock *s = c->priv;
+
+  while (c->tx_pos)
+    {
+      struct cli_out *o = c->tx_pos;
+
+      int len = o->wpos - o->outpos;
+      s->tbuf = o->outpos;
+      o->outpos = o->wpos;
+
+      if (sk_send(s, len) <= 0)
+	return;
+
+      c->tx_pos = o->next;
+    }
+
+  /* Everything is written */
+  s->tbuf = NULL;
+  cli_written(c);
+}
+
+void
+cli_write_trigger(cli *c)
+{
+  sock *s = c->priv;
+
+  if (s->tbuf == NULL)
+    cli_write(c);
+}
+
+static void
+cli_tx(sock *s)
+{
+  cli_write(s->data);
+}
+
+int
+cli_get_command(cli *c)
+{
+  sock *s = c->priv;
+  byte *t = c->rx_aux ? : s->rbuf;
+  byte *tend = s->rpos;
+  byte *d = c->rx_pos;
+  byte *dend = c->rx_buf + CLI_RX_BUF_SIZE - 2;
+
+  while (t < tend)
+    {
+      if (*t == '\r')
+	t++;
+      else if (*t == '\n')
+	{
+	  t++;
+	  c->rx_pos = c->rx_buf;
+	  c->rx_aux = t;
+	  *d = 0;
+	  return (d < dend) ? 1 : -1;
+	}
+      else if (d < dend)
+	*d++ = *t++;
+    }
+  c->rx_aux = s->rpos = s->rbuf;
+  c->rx_pos = d;
+  return 0;
+}
+
+static int
+cli_rx(sock *s, uint size UNUSED)
+{
+  cli_kick(s->data);
+  return 0;
+}
+
+static void
+cli_err(sock *s, int err)
+{
+  if (config->cli_debug)
+    {
+      if (err)
+	log(L_INFO "CLI connection dropped: %s", strerror(err));
+      else
+	log(L_INFO "CLI connection closed");
+    }
+  cli_free(s->data);
+}
+
+static int
+cli_connect(sock *s, uint size UNUSED)
+{
+  cli *c;
+
+  if (config->cli_debug)
+    log(L_INFO "CLI connect");
+  s->rx_hook = cli_rx;
+  s->tx_hook = cli_tx;
+  s->err_hook = cli_err;
+  s->data = c = cli_new(s);
+  s->pool = c->pool;		/* We need to have all the socket buffers allocated in the cli pool */
+  s->fast_rx = 1;
+  c->rx_pos = c->rx_buf;
+  c->rx_aux = NULL;
+  rmove(s, c->pool);
+  return 1;
+}
+
+static void
+cli_init_unix(uid_t use_uid, gid_t use_gid)
+{
+  sock *s;
+
+  cli_init();
+  s = cli_sk = sk_new(cli_pool);
+  s->type = SK_UNIX_PASSIVE;
+  s->rx_hook = cli_connect;
+  s->rbsize = 1024;
+  s->fast_rx = 1;
+
+  /* Return value intentionally ignored */
+  unlink(path_control_socket);
+
+  if (sk_open_unix(s, path_control_socket) < 0)
+    die("Cannot create control socket %s: %m", path_control_socket);
+
+  if (use_uid || use_gid)
+    if (chown(path_control_socket, use_uid, use_gid) < 0)
+      die("chown: %m");
+
+  if (chmod(path_control_socket, 0660) < 0)
+    die("chmod: %m");
+}
+
+/*
+ *	PID file
+ */
+
+static char *pid_file;
+static int pid_fd;
+
+static inline void
+open_pid_file(void)
+{
+  if (!pid_file)
+    return;
+
+  pid_fd = open(pid_file, O_WRONLY|O_CREAT, 0664);
+  if (pid_fd < 0)
+    die("Cannot create PID file %s: %m", pid_file);
+}
+
+static inline void
+write_pid_file(void)
+{
+  int pl, rv;
+  char ps[24];
+
+  if (!pid_file)
+    return;
+
+  /* We don't use PID file for uniqueness, so no need for locking */
+
+  pl = bsnprintf(ps, sizeof(ps), "%ld\n", (long) getpid());
+  if (pl < 0)
+    bug("PID buffer too small");
+
+  rv = ftruncate(pid_fd, 0);
+  if (rv < 0)
+    die("fruncate: %m");
+    
+  rv = write(pid_fd, ps, pl);
+  if(rv < 0)
+    die("write: %m");
+
+  close(pid_fd);
+}
+
+static inline void
+unlink_pid_file(void)
+{
+  if (pid_file)
+    unlink(pid_file);
+}
+
+
+/*
+ *	Shutdown
+ */
+
+void
+cmd_shutdown(void)
+{
+  if (cli_access_restricted())
+    return;
+
+  cli_msg(7, "Shutdown requested");
+  order_shutdown();
+}
+
+void
+async_shutdown(void)
+{
+  DBG("Shutting down...\n");
+  order_shutdown();
+}
+
+void
+sysdep_shutdown_done(void)
+{
+  unlink_pid_file();
+  unlink(path_control_socket);
+  log_msg(L_FATAL "Shutdown completed");
+  exit(0);
+}
+
+/*
+ *	Signals
+ */
+
+static void
+handle_sighup(int sig UNUSED)
+{
+  DBG("Caught SIGHUP...\n");
+  async_config_flag = 1;
+}
+
+static void
+handle_sigusr(int sig UNUSED)
+{
+  DBG("Caught SIGUSR...\n");
+  async_dump_flag = 1;
+}
+
+static void
+handle_sigterm(int sig UNUSED)
+{
+  DBG("Caught SIGTERM...\n");
+  async_shutdown_flag = 1;
+}
+
+void watchdog_sigalrm(int sig UNUSED);
+
+static void
+signal_init(void)
+{
+  struct sigaction sa;
+
+  bzero(&sa, sizeof(sa));
+  sa.sa_handler = handle_sigusr;
+  sa.sa_flags = SA_RESTART;
+  sigaction(SIGUSR1, &sa, NULL);
+  sa.sa_handler = handle_sighup;
+  sa.sa_flags = SA_RESTART;
+  sigaction(SIGHUP, &sa, NULL);
+  sa.sa_handler = handle_sigterm;
+  sa.sa_flags = SA_RESTART;
+  sigaction(SIGTERM, &sa, NULL);
+  sa.sa_handler = watchdog_sigalrm;
+  sa.sa_flags = 0;
+  sigaction(SIGALRM, &sa, NULL);
+  signal(SIGPIPE, SIG_IGN);
+}
+
+/*
+ *	Parsing of command-line arguments
+ */
+
+static char *opt_list = "c:dD:ps:P:u:g:flRkm:";
+static int parse_and_exit;
+char *bird_name;
+static char *use_user;
+static char *use_group;
+static int run_in_foreground = 0;
+char *click_tunnel_name;
+int click_tunnel_socket = 0;
+
+static void
+display_usage(void)
+{
+  fprintf(stderr, "Usage: %s [--version] [--help] [-c <config-file>] [OPTIONS]\n", bird_name);
+}
+
+static void
+display_help(void)
+{
+  display_usage();
+
+  fprintf(stderr,
+    "\n"
+    "Options: \n"
+    "  -c <config-file>     Use given configuration file instead\n"
+    "                       of prefix/etc/bird.conf\n"
+    "  -d                   Enable debug messages and run bird in foreground\n"
+    "  -D <debug-file>      Log debug messages to given file instead of stderr\n"
+    "  -f                   Run bird in foreground\n"
+    "  -g <group>           Use given group ID\n"
+    "  -h, --help           Display this information\n"
+    "  -l                   Look for a configuration file and a communication socket\n"
+    "                       file in the current working directory\n"
+    "  -p                   Test configuration file and exit without start\n"
+    "  -P <pid-file>        Create a PID file with given filename\n"
+    "  -R                   Apply graceful restart recovery after start\n"
+    "  -s <control-socket>  Use given filename for a control socket\n"
+    "  -u <user>            Drop privileges and use given user ID\n"
+    "  --version            Display version of BIRD\n"
+    "\n"
+    "Meraki options: \n"
+    "  -k                   Enable Click tunnel\n"
+    "  -m                   Click tunnel path\n");
+
+  exit(0);
+}
+
+static void
+display_version(void)
+{
+  fprintf(stderr, "BIRD version " BIRD_VERSION "\n");
+  exit(0);
+}
+
+static inline char *
+get_bird_name(char *s, char *def)
+{
+  char *t;
+  if (!s)
+    return def;
+  t = strrchr(s, '/');
+  if (!t)
+    return s;
+  if (!t[1])
+    return def;
+  return t+1;
+}
+
+static inline uid_t
+get_uid(const char *s)
+{
+  struct passwd *pw;
+  char *endptr;
+  long int rv;
+
+  if (!s)
+    return 0;
+
+  errno = 0;
+  rv = strtol(s, &endptr, 10);
+
+  if (!errno && !*endptr)
+    return rv;
+
+  pw = getpwnam(s);
+  if (!pw)
+    die("Cannot find user '%s'", s);
+
+  return pw->pw_uid;
+}
+
+static inline gid_t
+get_gid(const char *s)
+{
+  struct group *gr;
+  char *endptr;
+  long int rv;
+
+  if (!s)
+    return 0;
+
+  errno = 0;
+  rv = strtol(s, &endptr, 10);
+
+  if (!errno && !*endptr)
+    return rv;
+
+  gr = getgrnam(s);
+  if (!gr)
+    die("Cannot find group '%s'", s);
+
+  return gr->gr_gid;
+}
+
+static void
+parse_args(int argc, char **argv)
+{
+  int config_changed = 0;
+  int socket_changed = 0;
+  int c;
+
+  bird_name = get_bird_name(argv[0], "bird");
+  if (argc == 2)
+    {
+      if (!strcmp(argv[1], "--version"))
+	display_version();
+      if (!strcmp(argv[1], "--help"))
+	display_help();
+    }
+  while ((c = getopt(argc, argv, opt_list)) >= 0)
+    switch (c)
+      {
+      case 'c':
+	config_name = optarg;
+	config_changed = 1;
+	break;
+      case 'd':
+	debug_flag |= 1;
+	break;
+      case 'D':
+	log_init_debug(optarg);
+	debug_flag |= 2;
+	break;
+      case 'p':
+	parse_and_exit = 1;
+	break;
+      case 's':
+	path_control_socket = optarg;
+	socket_changed = 1;
+	break;
+      case 'P':
+	pid_file = optarg;
+	break;
+      case 'u':
+	use_user = optarg;
+	break;
+      case 'g':
+	use_group = optarg;
+	break;
+      case 'f':
+	run_in_foreground = 1;
+	break;
+      case 'l':
+	if (!config_changed)
+	  config_name = xbasename(config_name);
+	if (!socket_changed)
+	  path_control_socket = xbasename(path_control_socket);
+	break;
+      case 'R':
+	graceful_restart_recovery();
+	break;
+      case 'h':
+	display_help();
+	break;
+      case 'k':
+        click_tunnel_socket = 1;
+        break;
+      case 'm':
+        click_tunnel_name = optarg;
+        break;
+      default:
+	fputc('\n', stderr);
+	display_usage();
+	exit(1);
+      }
+  if (optind < argc)
+   {
+     display_usage();
+     exit(1);
+   }
+}
+
+/*
+ *	Hic Est main()
+ */
+
+void sockproxy_debug(enum csp_debug_class class, const char* format, va_list va);
+
+int
+main(int argc, char **argv)
+{
+#ifdef HAVE_LIBDMALLOC
+  if (!getenv("DMALLOC_OPTIONS"))
+    dmalloc_debug(0x2f03d00);
+#endif
+
+  parse_args(argc, argv);
+  if (debug_flag == 1)
+    log_init_debug("");
+  log_switch(debug_flag, NULL, NULL);
+
+  resource_init();
+  olock_init();
+  io_init();
+  rt_init();
+  if_init();
+  roa_init();
+  config_init();
+  CSP_register_debug(sockproxy_debug);
+
+  uid_t use_uid = get_uid(use_user);
+  gid_t use_gid = get_gid(use_group);
+
+  if (!parse_and_exit)
+  {
+    test_old_bird(path_control_socket);
+    cli_init_unix(use_uid, use_gid);
+  }
+
+  if (use_gid)
+    drop_gid(use_gid);
+
+  if (use_uid)
+    drop_uid(use_uid);
+
+  if (!parse_and_exit)
+    open_pid_file();
+
+  protos_build();
+  proto_build(&proto_click_kernel);
+  proto_build(&proto_click_iface);
+
+  struct config *conf = read_config();
+
+  if (parse_and_exit)
+    exit(0);
+
+  if (!(debug_flag||run_in_foreground))
+    {
+      pid_t pid = fork();
+      if (pid < 0)
+	die("fork: %m");
+      if (pid)
+	return 0;
+      setsid();
+      close(0);
+      if (open("/dev/null", O_RDWR) < 0)
+	die("Cannot open /dev/null: %m");
+      dup2(0, 1);
+      dup2(0, 2);
+    }
+
+  main_thread_init();
+
+  write_pid_file();
+
+  signal_init();
+
+  config_commit(conf, RECONFIG_HARD, 0);
+
+  graceful_restart_init();
+
+#ifdef LOCAL_DEBUG
+  async_dump_flag = 1;
+#endif
+
+  log(L_INFO "Started");
+  DBG("Entering I/O loop.\n");
+
+  io_loop();
+  bug("I/O loop died");
+}
diff --git a/sysdep/click/random.c b/sysdep/click/random.c
new file mode 100644
index 00000000..b1f5086f
--- /dev/null
+++ b/sysdep/click/random.c
@@ -0,0 +1,21 @@
+/*
+ *	BIRD Internet Routing Daemon -- Random Numbers
+ *
+ *	(c) 2000 Martin Mares <mj@ucw.cz>
+ *
+ *	Can be freely distributed and used under the terms of the GNU GPL.
+ */
+
+#include <stdlib.h>
+
+#include "nest/bird.h"
+
+u32
+random_u32(void)
+{
+  long int rand_low, rand_high;
+
+  rand_low = random();
+  rand_high = random();
+  return (rand_low & 0xffff) | ((rand_high & 0xffff) << 16);
+}
diff --git a/sysdep/click/timer.h b/sysdep/click/timer.h
new file mode 100644
index 00000000..b0f93307
--- /dev/null
+++ b/sysdep/click/timer.h
@@ -0,0 +1,89 @@
+/*
+ *	BIRD -- Unix Timers
+ *
+ *	(c) 1998 Martin Mares <mj@ucw.cz>
+ *
+ *	Can be freely distributed and used under the terms of the GNU GPL.
+ */
+
+#ifndef _BIRD_TIMER_H_
+#define _BIRD_TIMER_H_
+
+#include <time.h>
+
+#include "lib/resource.h"
+
+typedef time_t bird_clock_t;		/* Use instead of time_t */
+
+typedef struct timer {
+  resource r;
+  void (*hook)(struct timer *);
+  void *data;
+  uint randomize;			/* Amount of randomization */
+  uint recurrent;			/* Timer recurrence */
+  node n;				/* Internal link */
+  bird_clock_t expires;			/* 0=inactive */
+} timer;
+
+timer *tm_new(pool *);
+void tm_start(timer *, uint after);
+void tm_stop(timer *);
+void tm_dump_all(void);
+
+extern bird_clock_t now; 		/* Relative, monotonic time in seconds */
+extern bird_clock_t now_real;		/* Time in seconds since fixed known epoch */
+extern bird_clock_t boot_time;
+
+static inline int
+tm_active(timer *t)
+{
+  return t->expires != 0;
+}
+
+static inline bird_clock_t
+tm_remains(timer *t)
+{
+  return t->expires ? t->expires - now : 0;
+}
+
+static inline void
+tm_start_max(timer *t, bird_clock_t after)
+{
+  bird_clock_t rem = tm_remains(t);
+  tm_start(t, (rem > after) ? rem : after);
+}
+
+static inline timer *
+tm_new_set(pool *p, void (*hook)(struct timer *), void *data, uint rand, uint rec)
+{
+  timer *t = tm_new(p);
+  t->hook = hook;
+  t->data = data;
+  t->randomize = rand;
+  t->recurrent = rec;
+  return t;
+}
+
+
+struct timeformat {
+  char *fmt1, *fmt2;
+  bird_clock_t limit;
+};
+
+bird_clock_t tm_parse_date(char *);	/* Convert date to bird_clock_t */
+bird_clock_t tm_parse_datetime(char *);	/* Convert date to bird_clock_t */
+
+#define TM_DATETIME_BUFFER_SIZE 32	/* Buffer size required by tm_format_datetime */
+
+void tm_format_datetime(char *x, struct timeformat *fmt_spec, bird_clock_t t);
+int tm_format_real_time(char *x, size_t max, const char *fmt, bird_clock_t t);
+
+#define TIME_T_IS_64BIT (sizeof(time_t) == 8)
+#define TIME_T_IS_SIGNED ((time_t) -1 < 0)
+
+#define TIME_INFINITY							\
+  ((time_t) (TIME_T_IS_SIGNED ?						\
+	     (TIME_T_IS_64BIT ? 0x7fffffffffffffff : 0x7fffffff):	\
+	     (TIME_T_IS_64BIT ? 0xffffffffffffffff : 0xffffffff)))
+
+#endif
diff --git a/sysdep/click/unix.h b/sysdep/click/unix.h
new file mode 100644
index 00000000..1225a264
--- /dev/null
+++ b/sysdep/click/unix.h
@@ -0,0 +1,133 @@
+/*
+ *	BIRD -- Declarations Common to Unix Port
+ *
+ *	(c) 1998--2000 Martin Mares <mj@ucw.cz>
+ *	(c) 2014--2017 Cisco Systems, Inc.
+ *
+ *	Can be freely distributed and used under the terms of the GNU GPL.
+ */
+
+#ifndef _BIRD_UNIX_H_
+#define _BIRD_UNIX_H_
+
+#include <sys/socket.h>
+
+struct pool;
+struct iface;
+struct birdsock;
+struct rfile;
+
+/* main.c */
+
+extern char *bird_name;
+void async_config(void);
+void async_dump(void);
+void async_shutdown(void);
+void cmd_check_config(char *name);
+void cmd_reconfig(char *name, int type, int timeout);
+void cmd_reconfig_confirm(void);
+void cmd_reconfig_undo(void);
+void cmd_shutdown(void);
+void cmd_sockproxy_stats(void);
+void cmd_sockproxy_reset_stats(void);
+
+#define UNIX_DEFAULT_CONFIGURE_TIMEOUT	300
+
+#define UNIX_DEFAULT_LATENCY_LIMIT	(1 S_)
+#define UNIX_DEFAULT_WATCHDOG_WARNING	(5 S_)
+
+/* io.c */
+
+#define ERR(c) do { s->err = c; return -1; } while (0)
+#define ERR2(c) do { s->err = c; goto err; } while (0)
+#define ERR_MSG(c) do { errno = 0; s->err = c; return -1; } while (0)
+
+
+#define SOCKADDR_SIZE 32
+
+typedef struct sockaddr_bird {
+  struct sockaddr sa;
+  char padding[SOCKADDR_SIZE - sizeof(struct sockaddr)];
+} sockaddr;
+
+
+#ifdef IPV6
+#define BIRD_AF AF_INET6
+#define ipa_from_sa(x) ipa_from_sa6(x)
+#else
+#define BIRD_AF AF_INET
+#define ipa_from_sa(x) ipa_from_sa4(x)
+#endif
+
+
+/* This is sloppy hack, it should be detected by configure script */
+/* Linux systems have it defined so this is definition for BSD systems */
+#ifndef s6_addr32
+#define s6_addr32 __u6_addr.__u6_addr32
+#endif
+
+
+static inline ip_addr ipa_from_in4(struct in_addr a UNUSED6)
+{ return ipa_from_u32(ntohl(a.s_addr)); }
+
+static inline ip_addr ipa_from_in6(struct in6_addr a UNUSED4)
+{ return ipa_build6(ntohl(a.s6_addr32[0]), ntohl(a.s6_addr32[1]), ntohl(a.s6_addr32[2]), ntohl(a.s6_addr32[3])); }
+
+static inline ip_addr ipa_from_sa4(sockaddr *sa UNUSED6)
+{ return ipa_from_in4(((struct sockaddr_in *) sa)->sin_addr); }
+
+static inline ip_addr ipa_from_sa6(sockaddr *sa UNUSED4)
+{ return ipa_from_in6(((struct sockaddr_in6 *) sa)->sin6_addr); }
+
+static inline struct in_addr ipa_to_in4(ip_addr a)
+{ return (struct in_addr) { htonl(ipa_to_u32(a)) }; }
+
+#ifdef IPV6
+static inline struct in6_addr ipa_to_in6(ip_addr a)
+{ return (struct in6_addr) { .s6_addr32 = { htonl(_I0(a)), htonl(_I1(a)), htonl(_I2(a)), htonl(_I3(a)) } }; }
+#else
+/* Temporary dummy */
+static inline struct in6_addr ipa_to_in6(ip_addr a UNUSED)
+{ return (struct in6_addr) { .s6_addr32 = { 0, 0, 0, 0 } }; }
+#endif
+
+void sockaddr_fill(sockaddr *sa, int af, ip_addr a, struct iface *ifa, uint port);
+int sockaddr_read(sockaddr *sa, int af, ip_addr *a, struct iface **ifa, uint *port);
+
+
+#ifndef SUN_LEN
+#define SUN_LEN(ptr) ((size_t) (((struct sockaddr_un *) 0)->sun_path) + strlen ((ptr)->sun_path))
+#endif
+
+extern volatile int async_config_flag;
+extern volatile int async_dump_flag;
+extern volatile int async_shutdown_flag;
+
+void io_init(void);
+void io_loop(void);
+void io_log_dump(void);
+int sk_open_unix(struct birdsock *s, char *name);
+struct rfile *rf_open(struct pool *, char *name, char *mode);
+void *rf_file(struct rfile *f);
+int rf_fileno(struct rfile *f);
+void test_old_bird(char *path);
+
+
+/* krt.c bits */
+
+void krt_io_init(void);
+
+/* log.c */
+
+void main_thread_init(void);
+void log_init_debug(char *);		/* Initialize debug dump to given file (NULL=stderr, ""=off) */
+void log_switch(int debug, list *l, char *); /* Use l=NULL for initial switch */
+
+struct log_config {
+  node n;
+  uint mask;				/* Classes to log */
+  void *fh;				/* FILE to log to, NULL=syslog */
+  int terminal_flag;
+};
+
+#endif
-- 
2.22.0

